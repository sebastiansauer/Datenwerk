{
  "hash": "a147fb050063d44fa043c71800b395af",
  "result": {
    "engine": "knitr",
    "markdown": "---\ndate: 2023-12-20\ndraft: FALSE   # ACHTUNG DRAFT STEHT AUF TRUE!\ntitle: chatgpt-sentiment-loop-all\nexecute: \n  eval: true \n  \nhighlight-style: arrow \ncache: true\n\nextype: string\nexsolution: \"\"\ncategories:\n- textmining\n- nlp\n- transformer\n- chatgpt\n- sentiment\n---\n\n\n\n\n\n\n\n\n\n\n\n# Aufgabe\n\n\nFragen Sie ChatGPT via API zum Sentiment der Texte aus dem Germeval-2018-Datensatz (Test).\n\n\nHinweise:\n\n- Beachten Sie die [Standardhinweise des Datenwerks](https://datenwerk.netlify.app/hinweise).\n- Nutzen Sie Python, nicht R.\n- Das Verwenden der OpenAI-API kostet Geld. üí∏ Informieren Sie sich vorab √ºber die [Preise von OpenAI](https://openai.com/pricing). Um auf die API zugreifen zu k√∂nnen, m√ºssen Sie sich ein Konto angelegt haben und √ºber ein Guthaben verf√ºgen. Sie k√∂nnen unter <https://platform.openai.com/usage> Ihre Kosten pr√ºfen.\n\n\n\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n\n# L√∂sung\n\n\n## Achtung\n\n::: {.callout-attention}\nOpenAI hat eine neue API (Stand: 2023-11-23), V1.3.5. Der Code der alten API bricht. üíî $\\square$\n:::\n\n## Setup\n\n\nDie richtige venv nutzen:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(reticulate)\n#virtualenv_create(\"chatgpt\")\nuse_virtualenv(\"chatgpt\")\n```\n:::\n\n\n\nCheck zu Python:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nreticulate::py_config()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\npython:         /Users/sebastiansaueruser/.virtualenvs/chatgpt/bin/python\nlibpython:      /Users/sebastiansaueruser/.pyenv/versions/3.11.1/lib/libpython3.11.dylib\npythonhome:     /Users/sebastiansaueruser/.virtualenvs/chatgpt:/Users/sebastiansaueruser/.virtualenvs/chatgpt\nversion:        3.11.1 (main, Oct  4 2023, 18:12:06) [Clang 15.0.0 (clang-1500.0.40.1)]\nnumpy:          /Users/sebastiansaueruser/.virtualenvs/chatgpt/lib/python3.11/site-packages/numpy\nnumpy_version:  1.26.2\n\nNOTE: Python version was forced by use_python() function\n```\n\n\n:::\n:::\n\n\nGgf. noch Module installieren:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#reticulate::py_install(\"pandas\")\n#py_install(\"tiktoken\")\n#py_install(\"datar\")\n#py_install(\"scikit-learn\")\n```\n:::\n\n\n\n## R-Pakete und Python-Module\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(tidymodels)\n```\n:::\n\n\n\nModule importieren:\n\n\n::: {.cell}\n\n```{.python .cell-code}\nfrom openai import OpenAI\nimport pandas as pd\nimport numpy as np\nimport time\nfrom datetime import datetime\n#from sklearn.metrics import classification_report\nfrom sklearn.metrics import accuracy_score\n```\n:::\n\n\nVersionen der importierten Module:\n\n\n::: {.cell}\n\n```{.python .cell-code}\npd.__version__\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n'2.1.3'\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n````{.cell-code}\n```{{zsh openai-version-zsh}}\npip list | grep openai\n```\n````\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n[notice] A new release of pip is available: 23.3.1 -> 23.3.2\n[notice] To update, run: pip install --upgrade pip\nopenai             1.3.5\n```\n\n\n:::\n:::\n\n\nWir brauchen `>= 1.35`.\n\nDer Operator `|` ist die \"Pfeife\" der Kommandozeile, also sozusagen der \"UND-DANN-Befehl\".\n\n\n\n\n\n## Daten\n\nDaten importieren:\n\n\n::: {.cell}\n\n```{.python .cell-code}\ncsv_file_path_test = 'https://github.com/sebastiansauer/pradadata/raw/master/data-raw/germeval_test.csv'\n\ngermeval_test = pd.read_csv(csv_file_path_test)\n```\n:::\n\n\n\nDie ersten paar Texte herausziehen:\n\n\n::: {.cell}\n\n```{.python .cell-code}\nstart_pos = 0\nend_pos = 3531\ntweets = germeval_test[\"text\"].iloc[start_pos:(end_pos+1)].tolist()\n```\n:::\n\n\n\n## Prompt\n\nPrompt definieren:\n\n\n::: {.cell}\n\n```{.python .cell-code}\nprompt_stem  = \"Als KI mit Exertise in nat√ºrlicher Sprache und Emotionserkennung ist es Ihre Aufgabe, das Sentiment des folgenden Textes einzusch√§tzen. Bitte antworten Sie nur mit einem einzigen Wort, entweder 'positiv', 'neutral' oder 'negativ'. Ihre Antwort soll Ihre Insgesamt-Einsch√§tzung zum Sentiments des Textes zusammenfassen. Nach dem Doppelpunkt folgt der Text, dessen Sentiment Sie einsch√§tzen sollen: \"\n```\n:::\n\n\nGute Prompts k√∂nnen helfen, gute Antworten vom Modell zu erhalten.\n\n\n\nMit \"List Comprehension\" k√∂nnen wir die Tweets jeweils mit dem Prompt verkn√ºpfen:\n\n\n::: {.cell}\n\n```{.python .cell-code}\nprompts = [prompt_stem + tweet for tweet in tweets]\nprompts[0]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\"Als KI mit Exertise in nat√ºrlicher Sprache und Emotionserkennung ist es Ihre Aufgabe, das Sentiment des folgenden Textes einzusch√§tzen. Bitte antworten Sie nur mit einem einzigen Wort, entweder 'positiv', 'neutral' oder 'negativ'. Ihre Antwort soll Ihre Insgesamt-Einsch√§tzung zum Sentiments des Textes zusammenfassen. Nach dem Doppelpunkt folgt der Text, dessen Sentiment Sie einsch√§tzen sollen: Meine Mutter hat mir erz√§hlt, dass mein Vater einen Wahlkreiskandidaten nicht gew√§hlt hat, weil der gegen die Homo-Ehe ist ‚ò∫\"\n```\n\n\n:::\n:::\n\n\nCheck: Wie viele Elemente hat die Liste `prompts`?\n\n\n::: {.cell}\n\n```{.python .cell-code}\nlen(prompts)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n3532\n```\n\n\n:::\n:::\n\n\n\n\nLaut OpenAI kostet 1k Token f√ºr das Modell `gpt-3.5-turbo-1106` $0.001.\n\n\n## Authentifizieren\n\nAnmelden bei OpenAI:\n\n\n::: {.cell}\n\n```{.python .cell-code}\nclient = OpenAI()\n```\n:::\n\n\n\n::: {.callout-note}\nDieses Anmeldeverfahren setzt voraus, dass in `.Renviron` die Variable `OPENAI_API_KEY` hinterlegt ist. $\\square$\n:::\n\n\n\n\n\n\nAnfrage an die API, in eine Funktion gepackt:\n\n\n::: {.cell}\n\n```{.python .cell-code}\ndef get_completion(prompt, client_instance, model=\"gpt-3.5-turbo\"):\n  messages = [{\"role\": \"user\", \"content\": prompt}]\n  response = client_instance.chat.completions.create(\n    model=model,\n    messages=messages,\n    max_tokens=50,\n    temperature=0,\n  )\n  return response.choices[0].message.content\n```\n:::\n\n\n\n## API anfragen\n\nUnd jetzt als Schleife. Ergebnisliste anlegen, am Anfang noch leer:\n\n\n::: {.cell}\n\n```{.python .cell-code}\npredicted_values = []\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nstart_time = time.time()\n\nfor prompt in prompts:\n  result = get_completion(prompt, client) \n  predicted_values.append(result)\n\nend_time = time.time()\nend_time - start_time\n```\n:::\n\n\n\n\nVoil√†:\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nprint(predicted_values[:5])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[]\n```\n\n\n:::\n:::\n\n\n## Als CSV speichern\n\n\n::: {.cell}\n\n```{.python .cell-code}\nid_seq = [i for i in range(start_pos, end_pos + 1)]\npredicted_values_df = pd.DataFrame(id_seq, columns = [\"id\"])\npredicted_values_df[\"pred\"] = predicted_values\n\nnow = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\ncsv_output_name = \"germeval_test_preds_at_\" + now\npredicted_values_df.to_csv(csv_output_name)\n```\n:::\n\n\n\n## Oder Vorhersagen aus CSV importieren\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\npreds_path = 'https://raw.githubusercontent.com/sebastiansauer/Datenwerk2/main/posts/chatgpt-sentiment-loop-all/germeval_test_preds_at_2023-12-20%2014%3A06%3A00'\n\npreds = pd.read_csv(preds_path)\n\npreds.head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Unnamed: 0  id     pred\n0           0   0  neutral\n1           1   1  negativ\n2           2   2  negativ\n3           3   3  neutral\n4           4   4  negativ\n```\n\n\n:::\n:::\n\n\nMan kann eine Python-Variable an R √ºbergeben:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npreds_r <- py$preds\n```\n:::\n\n\n## Vorhersagen (Predictions) betrachten\n\n\nZ√§hlen wir mal kurz aus:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npreds_r |> \n  count(pred) |> \n  slice(3:5)  # zwei komische, kaputte Zeilen, weg damit\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     pred    n\n1 negativ 1792\n2 neutral 1354\n3 positiv  384\n```\n\n\n:::\n:::\n\n\nOder in Python:\n\n\n::: {.cell}\n\n```{.python .cell-code}\npreds[\"pred\"].value_counts()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\npred\nnegativ                                                                             1792\nneutral                                                                             1354\npositiv                                                                              384\nmuss. #AfD #Grenzschutz #Deutschland: negativ                                          1\nkommen, in den eigenen vier W√§nden haben. Das ist doch wohl klar. #ltwlsa #ltw21       1\nName: count, dtype: int64\n```\n\n\n:::\n:::\n\nPuh, das ist ein bisschen was kaput gegangen.\n\n## Predictions reparieren\n\n\n::: {.cell}\n\n```{.python .cell-code}\nallowed_preds = [\"positiv\", \"neutral\", \"negativ\"]\npreds.loc[~preds[\"pred\"].isin(allowed_preds), \"pred\"] = np.nan\n```\n:::\n\n\nCheck:\n\n\n::: {.cell}\n\n```{.python .cell-code}\npreds[\"pred\"].value_counts()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\npred\nnegativ    1792\nneutral    1354\npositiv     384\nName: count, dtype: int64\n```\n\n\n:::\n:::\n\n\n\n\nPasst!\n\n\n\n## Scoring vorbereiten\n\nWas waren noch mal die Variablen unser Tabelle?\n\n\n::: {.cell}\n\n```{.python .cell-code}\ngermeval_test.columns\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nIndex(['id', 'text', 'c1', 'c2'], dtype='object')\n```\n\n\n:::\n:::\n\n\nDie ersten paar Werte:\n\n\n::: {.cell}\n\n```{.python .cell-code}\ngermeval_test.head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   id                                               text       c1     c2\n0   1  Meine Mutter hat mir erz√§hlt, dass mein Vater ...    OTHER  OTHER\n1   2  @Tom174_ @davidbest95 Meine Reaktion; |LBR| Ni...    OTHER  OTHER\n2   3  #Merkel rollt dem Emir von #Katar, der islamis...    OTHER  OTHER\n3   4  ‚ÄûMerle ist kein junges unschuldiges M√§dchen‚Äú K...    OTHER  OTHER\n4   5  @umweltundaktiv Asylantenflut bringt eben nur ...  OFFENSE  ABUSE\n```\n\n\n:::\n:::\n\n\n\nRescore im Test-Set:\n\n\n::: {.cell}\n\n```{.python .cell-code}\ndf = germeval_test\ndf[\"c1\"] = df[\"c1\"].replace({\"OFFENSE\": \"negativ\"})\n\ndf[\"c1\"].value_counts()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nc1\nOTHER      2330\nnegativ    1202\nName: count, dtype: int64\n```\n\n\n:::\n:::\n\n\nRescore in den Vorhersagen\n\n\n::: {.cell}\n\n```{.python .cell-code}\npreds[\"pred\"] = preds[\"pred\"].replace({\"neutral\": \"OTHER\", \"positiv\": \"OTHER\"})\n\npreds[\"pred\"].value_counts()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\npred\nnegativ    1792\nOTHER      1738\nName: count, dtype: int64\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\npreds_list = preds[\"pred\"].tolist()\n```\n:::\n\n\nHier ist die *Liste* der wahren Werte:\n\n\n::: {.cell}\n\n```{.python .cell-code}\ny = df[\"c1\"].values.tolist()\n```\n:::\n\n\n## Scoring\n\n\n::: {.cell}\n\n```{.python .cell-code}\naccuracy = accuracy_score(y, preds_list)\nprint(\"Accuracy:\", accuracy)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nAccuracy: 0.7355605889014722\n```\n\n\n:::\n:::\n\n\n\n\n\n\nOder  mit `tidymodels`; zuerst aufbereiten:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny_truth = as.factor(py$y)\ny_pred = py$preds_list \n\n# replace NAN with NA and convert to factor:\ny_pred = as.character(y_pred) \ny_pred[is.nan(y_pred)] <- NA\ny_pred[!y_pred %in% c(\"negativ\", \"OTHER\")] <- NA\ny_pred <- as.factor(y_pred)\n\ntable(y_pred)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ny_pred\nnegativ   OTHER \n   1792    1738 \n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\naccuracy_vec(truth = y_truth,\n             estimate = y_pred)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.7359773\n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}