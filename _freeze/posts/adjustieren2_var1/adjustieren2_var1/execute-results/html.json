{
  "hash": "ae2080b7197c0357d7fa1702ce463a48",
  "result": {
    "engine": "knitr",
    "markdown": "---\nextype: string\nexsolution: r regression_formel\nexname: adjustieren2_var1\nexpoints: 1\ncategories:\n- lm\n- regression\n- bayes\n- adjust\n- string\ndate: '2023-11-08'\nslug: adjustieren2_var1\ntitle: adjustieren2_var1\n\n---\n\n\n\n\n\n\n\n\n\n\n# Aufgabe\n\n\nBetrachten Sie folgendes Modell, das den Zusammenhang des Preises (`price`) \nund dem Gewicht (`carat`) von Diamanten untersucht (Datensatz `diamonds`).\n\n\n::: {.cell hash='adjustieren2_var1_cache/html/unnamed-chunk-1_6a5f88d1d264058d082e42f43ca207ae'}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(easystats)\nlibrary(rstanarm)\ndiamonds <- read_csv(\"https://vincentarelbundock.github.io/Rdatasets/csv/ggplot2/diamonds.csv\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 53940 Columns: 11\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (3): cut, color, clarity\ndbl (8): rownames, carat, depth, table, price, x, y, z\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n:::\n\n\n\n\nAber zuerst zentrieren wir den metrischen Prädiktor `carat`, \num den Achsenabschnitt besser interpretieren zu können. \n\n\n::: {.cell hash='adjustieren2_var1_cache/html/unnamed-chunk-2_808572fb96976f5610fee95ed5e455c1'}\n\n```{.r .cell-code}\ndiamonds2 <-\n  diamonds %>% \n  mutate(carat_z = carat - mean(carat, na.rm = TRUE))\n```\n:::\n\n\nDann berechnen wir ein (bayesianisches) Regressionsmodell, \nwobei wir auf die Standardwerte der Prior zurückgreifen.\n\n\n::: {.cell hash='adjustieren2_var1_cache/html/unnamed-chunk-3_c643f067e3c66b980209ae9f71989900'}\n\n```{.r .cell-code}\nlibrary(rstanarm)\nlm1 <- stan_glm(price ~ carat_z, data = diamonds2,\n                refresh = 0)\nparameters(lm1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nParameter   |  Median |             95% CI |   pd |  Rhat |     ESS |                       Prior\n-------------------------------------------------------------------------------------------------\n(Intercept) | 3932.64 | [3919.83, 3945.55] | 100% | 1.004 | 1178.00 | Normal (3932.80 +- 9973.60)\ncarat_z     | 7755.90 | [7727.59, 7783.52] | 100% | 1.000 | 4716.00 |   Normal (0.00 +- 21040.85)\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\nUncertainty intervals (equal-tailed) and p-values (two-tailed) computed\n  using a MCMC distribution approximation.\n```\n\n\n:::\n:::\n\n\n\n\nZur Verdeutlichung ein Diagramm zum Modell:\n\n\n::: {.cell hash='adjustieren2_var1_cache/html/unnamed-chunk-4_6ed1a135a8df56d10eeda363bb2f17e7'}\n\n```{.r .cell-code}\ndiamonds2 %>% \n  ggplot() +\n  aes(x = carat_z, y = price) +\n  geom_point() + \n  geom_smooth(method = \"lm\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`geom_smooth()` using formula = 'y ~ x'\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](unnamed-chunk-4-1.png){fig-pos='H' width=384}\n:::\n:::\n\n\n\nOder so:\n\n\n::: {.cell hash='adjustieren2_var1_cache/html/unnamed-chunk-5_3d5742c5aceebedd3ce2cef5754231d5'}\n\n```{.r .cell-code}\nestimate_relation(lm1) |> plot()\n```\n\n::: {.cell-output-display}\n![](unnamed-chunk-5-1.png){fig-pos='H' width=384}\n:::\n:::\n\n\n\n\n*Aufgabe*:\n\nGeben Sie eine Regressionsformel an, die `lm1` ergänzt, so dass die Schliffart (`cut`) des Diamanten kontrolliert (adjustiert) wird. \nAnders gesagt: Das Modell soll die mittleren Preise für jede der fünf Schliffarten angeben. \n\n\n\n\n\n\n\n\n*Hinweis*: \n\n- Geben Sie nur die Regressionsformel an. \n- Lassen Sie zwischen Termen der Regressionsformel jeweils ein Leerzeichen Abstand.\n- Beziehen Sie sich auf das Modell bzw. die Angaben oben.\n- Es gibt (laut Datensatz) folgende Schliffarten (und zwar in der folgenden Reihenfolge):\n\n\n::: {.cell hash='adjustieren2_var1_cache/html/unnamed-chunk-6_2fb0f4a403f74fa3bc8b912deaae9c3a'}\n\n```{.r .cell-code}\ndiamonds %>% \n  distinct(cut)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 1\n  cut      \n  <chr>    \n1 Ideal    \n2 Premium  \n3 Good     \n4 Very Good\n5 Fair     \n```\n\n\n:::\n:::\n\n\n\n\n\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n\n# Lösung\n\n\n::: {.cell hash='adjustieren2_var1_cache/html/unnamed-chunk-7_945cee9abf56311c44c762b526a06c38'}\n\n:::\n\n\n\n\nDie richtige Antwort lautet: `price ~ carat_z + cut` \n\nDas Modell könnten wir so berechnen:\n\n\n::: {.cell hash='adjustieren2_var1_cache/html/unnamed-chunk-8_f3fc30d21f1acedce64cb6cdc5eff5d5'}\n\n```{.r .cell-code}\nlm2 <- stan_glm(price ~ carat_z + cut, data = diamonds2,\n                refresh = 0)  # verhindert einen Haufen unnötigen Output\nparameters(lm2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nParameter    |  Median |             95% CI |   pd |  Rhat |     ESS |                       Prior\n--------------------------------------------------------------------------------------------------\n(Intercept)  | 2401.60 | [2326.67, 2475.70] | 100% | 1.000 | 1022.00 | Normal (3932.80 +- 9973.60)\ncarat_z      | 7871.06 | [7844.55, 7898.35] | 100% | 0.999 | 3734.00 |   Normal (0.00 +- 21040.85)\ncutGood      | 1124.68 | [1040.23, 1213.25] | 100% | 1.000 | 1224.00 |   Normal (0.00 +- 34685.38)\ncutIdeal     | 1804.40 | [1726.43, 1883.62] | 100% | 1.000 | 1083.00 |   Normal (0.00 +- 20362.28)\ncutPremium   | 1443.13 | [1365.40, 1520.66] | 100% | 1.000 | 1099.00 |   Normal (0.00 +- 22862.49)\ncutVery Good | 1513.52 | [1435.77, 1594.26] | 100% | 1.000 | 1092.00 |   Normal (0.00 +- 23922.15)\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\nUncertainty intervals (equal-tailed) and p-values (two-tailed) computed\n  using a MCMC distribution approximation.\n```\n\n\n:::\n:::\n\n\n\nOder auch so, mit der klassischen Regression:\n\n\n\n\nlm(price ~ carat_z + cut, data = diamonds2)\ngi```\n\n\nDas führt zu ähnlichen Ergebnissen.\n\n\nMan könnte hier noch einen Interaktionseffekt ergänzen.\n\n\n\n---\n\nCategories: \n\n- lm\n- regression\n- bayes\n- adjust\n- string\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}