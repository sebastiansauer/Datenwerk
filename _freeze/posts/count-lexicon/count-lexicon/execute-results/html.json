{
  "hash": "2b14a965e206a5e99025c858ed0ca493",
  "result": {
    "engine": "knitr",
    "markdown": "---\nexname: count-lexicon\nexpoints: 1\nextype: string\nexsolution: NA\ncategories:\n- textmining\n- nlp\n- regex\n- string\ndate: '2023-11-08'\nslug: count-lexicon\ntitle: count-lexicon\n\n---\n\n\n\n\n\n# Aufgabe\n\nGegeben eines (mehrelementigen) Strings, `my_string`, und eines Lexicons, `my_lexicon`, zählen Sie, wie häufig sich ein Wort aus dem Lexikon in einem Element des Strings wiederfindet.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_string <-\n  c(\"Heute ist ein schöner Tag\", \"Was geht in dieser Woche?\")\n\n\nmy_lexicon <- c(\"Tag\", \"Woche\", \"Jahr\")\n```\n:::\n\n\n\n\nHinweise:\n\n- Orientieren Sie sich im Übrigen an den [allgemeinen Hinweisen des Datenwerks](https://datenwerk.netlify.app/hinweise).\n- Nutzen Sie die Funktion `count_lexicon` aus `{{prada}}`. Das Paket können Sie [hier](https://github.com/sebastiansauer/prada) herunterladen/installieren.\n\n\n\n\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n\n# Lösung\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.3     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.0\n✔ ggplot2   3.4.4     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.0\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n\n\n:::\n:::\n\n\n\n# Paket `prada`\n\nEine Möglichkeit ist es, die Funktion `count_lexion` aus dem Paket [`prada`](https://rdrr.io/github/sebastiansauer/prada/) zu nutzen.\n\nMan kann es so installieren: `remotes::install_github(\"sebastiansauer/prada\")`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(prada)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_int(my_string,  \n        ~ count_lexicon(.x, my_lexicon))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 1\n```\n\n\n:::\n:::\n\n\n\nSo können Sie sich den Quellcode einer Funktion, z.B. `count_lexicon()` anschauen:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncount_lexicon\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nfunction(txt, lexicon){\n  # convert strings to lower letters:\n  txt <- tolower(txt)\n  lexicon <- tolower(lexicon)\n\n  # build regex query:\n  lexicon_regex <- paste0(\"^\", lexicon, \"$\", collapse = \"|\")\n\n  # split string into words:\n  string_in_words <- unlist(stringr::str_split(txt, pattern = stringr::boundary(\"word\")))\n\n  # search:\n  pattern_detected_in_string_count <- sum(stringr::str_detect(string_in_words, pattern = lexicon_regex))\n\n  # return:\n  return(pattern_detected_in_string_count)\n}\n<bytecode: 0x7f9fdc57df80>\n<environment: namespace:prada>\n```\n\n\n:::\n:::\n\n\n\nIn dem Paket gibt es noch zwei Varianten für diese Funktion, die auf einem Join aufbauen.\n\n\n\n# Selbstgestrickt\n\nHier ist eine zweite Variante ohne besondere Pakete (außer `stringr`).\n\n\nWir definieren eine entsprechende Funktion:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Funktion, um die Anzahl der Übereinstimmungen eines Lexikons in einem String zu zählen\ncount_lexicon_matches <- function(string, lexicon) {\n  # Verketten Sie die Wörter im Lexikon mit dem |-Operator, um ein reguläres Ausdrucksmuster zu erstellen\n  lexicon_pattern <- paste(lexicon, collapse = \"|\")\n  # Verwenden Sie str_count, um die Anzahl der Übereinstimmungen zu zählen\n  matches <- str_count(string, lexicon_pattern)\n  return(matches)\n}\n```\n:::\n\n\n\nWir zählen  die Übereinstimmungen in jedem Element des Strings:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmatches_per_element <- sapply(my_string, count_lexicon_matches, lexicon = my_lexicon)\n\n# Ergebnis ausgeben:\nprint(matches_per_element)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nHeute ist ein schöner Tag Was geht in dieser Woche? \n                        1                         1 \n```\n\n\n:::\n:::\n\n\n\nAnstelle von `sapply` kann man das tidyverse-Pendant, `map` nutzen:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_int(my_string,  \n        ~ count_lexicon_matches(.x, my_lexicon))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 1\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n---\n\nCategories: \n\n- textmining\n- nlp\n- regex\n- string\n\n",
    "supporting": [
      "count-lexicon_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}