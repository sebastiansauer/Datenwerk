{
  "hash": "ca6817d48de4eaa9c804317569462834",
  "result": {
    "engine": "knitr",
    "markdown": "---\nexname: bayes2\nextype: num\nexsolution: r exams::fmt(sol)\nexshuffle: no\nextol: 0.02\nexpoints: 1\ncategories:\n- R\n- bayes\n- probability\n- num\ndate: '2023-11-08'\nslug: bayes2\ntitle: bayes2\n\n---\n\n\n\n\n\n\n\n\n\n\n\n\n\n# Aufgabe\n\n\n\nWir haben eine Münze $n=10$ Mal geworfen. Unsere Daten ($D$) sind: 8 Mal lag \"Kopf\" oben. \nGegeben dieser Datenlage, wie hoch ist die Wahrscheinlichkeit für das Ereignis $F$ (*F*alschspieler-Münze), dass die Münze also gezinkt ist auf $p=.8$? \nApriori sind wir indifferent, ob die Münze gezinkt ist oder nicht ($\\neg F$, also $p=.5$). \nDer Einfachheit halber gehen wir davon aus, dass es nur zwei Zustände für die Münze geben kann, gezinkt ($F$) oder nicht gezinkt ($\\neg F$).\n\n*Aufgabe*: Berechnen Sie die Wahrscheinlichkeit, dass die Münze gezinkt ist ($F$), gegeben der Datenlage $D$!\n\nHinweise:\n\n- Orientieren Sie sich im Übrigen an den [allgemeinen Hinweisen des Datenwerks](https://datenwerk.netlify.app/hinweise).\n\n\n\n\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n</br>\n\n# Lösung\n\nGesucht ist die Wahrscheinlichkeit, dass die Münze gezinkt ist, gegeben der beobachteten Daten: $Pr(F|D)$.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\np1 = .8\np2 = .5\nn = 10\nk = 8\n```\n:::\n\n\n\n\n\n\nEs gilt:\n\n$Pr(F|D) = \\frac{L \\times Priori}{Evidenz} = \\frac{Pr(D|F) Pr(F)}{Pr(D)} =  \\frac{Pr(D|F) Pr(F)}{Pr(D|F)Pr(F)  + {Pr(D|\\neg F)Pr(\\neg F)}}$\n\nDie Priori-Wahrscheinlichkeit für die Hypothese, dass die Münze *gezinkt* ist, beträgt 1/2, da wir indifferent sind: $Pr(F) = 1/2$.\n\nDie Likelihood, L, berechnet sich so:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nL_gezinkt <- dbinom(x = k, size = n, prob = p1)\nL_gezinkt\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.3019899\n```\n\n\n:::\n:::\n\n\n\n\n\nDer Zähler des Bruchs (unstand. Post) berechnet sich so:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nPost_unstand <- L_gezinkt * 1/2\nPost_unstand\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.1509949\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nLikelihood für die Daten, wenn die Münze nicht gezinkt ist:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nL_fair <- dbinom(x = k, size = n, prob = p2)\nL_fair\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.04394531\n```\n\n\n:::\n:::\n\n\n\n\n\nDie unstand. Post-Wahrscheinlichkeit für die Hypothese, dass die Münze nicht gezinkt ist, gegeben der Daten:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nPost_unstand2 <- L_fair * 1/2\nPost_unstand2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.02197266\n```\n\n\n:::\n:::\n\n\n\n\n\nDie Evidenz, E, berechnet sich als Summe aller unstand. Post-Wahrscheinlichkeiten (also über alle möglichen Hypothesen, d.h. $F$ und $\\neg F$, also $L$ plus $L_2$):\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nE <- Post_unstand + Post_unstand2\nE\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.1729676\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\nDie standardisierte Post-Wahrscheinlichkeit ist also die unstand. Post-Wahrscheinlichkeit geteilt durch die Evidenz:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nPost_std <- Post_unstand / E\nPost_std\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.8729666\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n:::\n\n\n\n\n\n\n*Antwort*: Die Lösung beträgt `0.87`.\n\n\nAlternativ zur Formal kann man auch eine Bayesbox verwenden.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(prada)\nbayesbox(hyps = c(\"fair\", \"gezinkt\"),\n         priors = c(1/2, 1/2),\n         liks = c(L_fair, L_gezinkt))\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|hyps    | priors|      liks| post_unstand|  post_std|\n|:-------|------:|---------:|------------:|---------:|\n|fair    |    0.5| 0.0439453|    0.0219727| 0.1270334|\n|gezinkt |    0.5| 0.3019899|    0.1509949| 0.8729666|\n\n</div>\n:::\n:::\n\n\n\n\n\n\n\n\n---\n\nCategories: \n\n- R\n- bayes\n- probability\n- num\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}