{
  "hash": "b77a92e6fed43fc287285bee1730d002",
  "result": {
    "engine": "knitr",
    "markdown": "---\ndate: 2024-05-08  # HEUTIGES DATUM EINTRAGEN\ndraft: FALSE   # ACHTUNG DRAFT STEHT AUF TRUE!\ntitle: oecd-yacsda\nexecute: \n  \n  eval: true \nhighlight-style: arrow \ncache: true\ntoc: true\nnumber-sections: true\nextype: string\nexsolution: \"\"\nexshuffle: no\ncategories:\n- eda  # ENTER CATEGORIES HERE\n- datawrangling\n- vis\n- yacsda\n- R \n\n\nbibliography: \"../../library-ses.bib\"\n\n---\n\n\n\n\n\n\n\n::: {.cell}\n\n:::\n\n\n**Fallstudie: Explorative Datenanalyse zum Datensatz \"OECD Wellbeing\"**\n\n(YACSDA: Yet another Case Study on Data Analysis)\n\n\n\n# Grundlagen\n\n:::{.callout-tip}\nWenn Sie nicht mehr weiter wissen, googeln Sie nach dem Problem. Oder fragen Sie einen ChatBot, z.B. ChatGPT. $\\square$\n:::\n\n\n:::{.callout-important}\nIm Folgenden werden mitunter mehrere Lösungswege präsentiert. Sie können sich den Weg aussuchen, der Ihnen am besten gefällt. Sie müssen *nicht* alle Wege verstehen oder gar beherrschen. Einer reicht. $\\square$\n:::\n\n## Hintergrund\n\n\n\nIn diesem Post untersuchen wir einige Aspekte der explorativen Datenanalyse für den Datensatz `oecd wellbeing` aus dem Jahr 2016.\n\n*Hinweis*: Als *Vertiefung*  gekennzeichnete Abschnitt sind *nicht* prüfungsrelevant.\n\n\n\n\n\n## Benötigte Pakete\n\nEin Standard-Paket zur grundlegenden Datenanalyse bzw. des Datenjudos ist `tidyverse`. Darüber hinaus verwenden wir noch zwei Pakete zur Visualisierung und eines für den Komfort.\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)  # Datenjudo\nlibrary(easystats)  # Komfort \nlibrary(DataExplorer)  # Data vis\nlibrary(ggpubr)  # Data vis\n```\n:::\n\n\n\n## Datensatz laden\n\nDer Datensatz kann [hier](https://stats.oecd.org/Index.aspx?DataSetCode=RWB) bezogen werden.\n\nDoi: https://doi.org/10.1787/data-00707-en.\n\n\nFalls der Datensatz lokal (auf Ihrem Rechner) vorliegt, können Sie ihn in gewohnter Manier importieren. Geben Sie dazu den Pfad zum Datensatz ein; bei mir sieht das so aus:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\noecd <- read.csv(\"/Users/sebastiansaueruser/datasets/oecd_wellbeing.csv\")\n```\n:::\n\n\nLiegt die Datendatei im *gleichen Verzeichnis*  wie Ihre R-/Quarto-/Rmd-Datei, dann brauchen Sie *nur* den Dateinamen, *nicht* den Pfad, anzugeben.\n\n\n*Alternativ* können Sie die Daten direkt von einem Server beziehen:\n\n::: {.cell}\n\n```{.r .cell-code}\noecd <- read.csv(\"https://raw.githubusercontent.com/sebastiansauer/2021-sose/master/data/OECD/oecd-wellbeing.csv\")\n```\n:::\n\n\n\n## Erster Blick\n\n\n::: {.cell}\n\n```{.r .cell-code}\nglimpse(oecd)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 429\nColumns: 15\n$ Country                  <chr> \"Australia\", \"Australia\", \"Australia\", \"Austr…\n$ Region                   <chr> \"New South Wales\", \"Victoria\", \"Queensland\", …\n$ region_type              <chr> \"country_part\", \"country_part\", \"country_part…\n$ Code                     <chr> \"AU1\", \"AU2\", \"AU3\", \"AU4\", \"AU5\", \"AU6\", \"AU…\n$ Education                <dbl> 8.0, 8.1, 7.8, 7.3, 7.6, 6.5, 8.1, 9.5, 8.8, …\n$ Jobs                     <dbl> 8.1, 7.9, 8.1, 7.8, 8.8, 7.6, 8.7, 9.3, 7.8, …\n$ Income                   <dbl> 6.8, 5.9, 6.3, 6.1, 7.9, 5.4, 8.2, 10.0, 5.7,…\n$ Safety                   <dbl> 8.8, 9.5, 9.5, 9.0, 8.6, 8.8, 0.0, 10.0, 9.7,…\n$ Health                   <dbl> 9.0, 9.5, 8.3, 8.5, 9.3, 5.4, 2.4, 9.3, 6.7, …\n$ Environment              <dbl> 9.8, 8.6, 9.9, 9.4, 9.6, 10.0, 9.2, 9.1, 3.5,…\n$ Civic_engagement         <dbl> 10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 8.4, 10.0…\n$ Accessiblity_to_services <dbl> 7.2, 7.5, 7.7, 7.2, 7.8, 6.8, 7.8, 8.7, 8.0, …\n$ Housing                  <dbl> 7.2, 7.8, 8.3, 8.3, 8.9, 8.3, 5.6, 8.3, 6.1, …\n$ Community                <dbl> 8.9, 9.3, 8.6, 8.6, 8.5, 8.6, 10.0, 9.8, 8.3,…\n$ Life_satisfaction        <dbl> 7.8, 8.5, 8.1, 8.5, 7.8, 9.6, 7.0, 9.6, 7.8, …\n```\n\n\n:::\n:::\n\n\nWie `glimpse()` aufzeigt, liegen also einige qualitative (kategoriale, `chr`, vom Typ \"Text\") und einige quantitative (metrische, `dbl`) Variablen vor. \nDie qualitativen Variablen sind für eine direkte Analyse weniger interessant; vielmehr ist es interessant, die Statistiken auf die *Gruppen* (Stufen, Level) der qualitativen Variablen aufzusplitten.\n\nBetrachten wir aber zu Beginn die metrischen Variablen einzeln (univariat).\n\n\n## Deskriptive Statistiken zu den metrischen Variablen, einzeln (univariat)\n\nZentrale Statistiken zu den metrischen Variablen lassen sich auf mehreren Wegen mit R berechnen. Hier ist ein Weg:\n\n::: {.cell}\n\n```{.r .cell-code}\ndescribe_distribution(oecd)\n```\n:::\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n\n\n|Variable                 | Mean|   SD|  IQR| Min| Max| Skewness| Kurtosis|   n| n_Missing|\n|:------------------------|----:|----:|----:|---:|---:|--------:|--------:|---:|---------:|\n|Education                | 6.81| 2.97| 3.50|   0|  10|    -1.08|    -0.02| 426|         3|\n|Jobs                     | 6.45| 2.41| 2.90|   0|  10|    -0.96|     0.48| 429|         0|\n|Income                   | 4.11| 2.70| 3.40|   0|  10|     0.44|    -0.38| 429|         0|\n|Safety                   | 7.05| 3.23| 3.80|   0|  10|    -1.18|     0.10| 429|         0|\n|Health                   | 5.73| 2.93| 5.20|   0|  10|    -0.33|    -1.15| 429|         0|\n|Environment              | 5.40| 2.73| 4.35|   0|  10|    -0.11|    -0.89| 429|         0|\n|Civic_engagement         | 5.05| 2.85| 4.10|   0|  10|    -0.03|    -0.91| 429|         0|\n|Accessiblity_to_services | 6.53| 2.65| 2.60|   0|  10|    -1.13|     0.50| 429|         0|\n|Housing                  | 4.80| 3.02| 5.50|   0|  10|    -0.06|    -1.12| 427|         2|\n|Community                | 6.88| 2.75| 3.25|   0|  10|    -1.13|     0.32| 425|         4|\n|Life_satisfaction        | 5.80| 2.90| 4.90|   0|  10|    -0.47|    -0.87| 425|         4|\n\n\n:::\n:::\n\n\nJetzt gehen wir weiter zur Visualisierung der Verteilung der metrischen Variablen.\nAuch hier gibt es wieder viele Lösungen.\n\nEs reicht, wenn Sie mit *einer* Lösung vertraut sind.\n\n### Mit ggpubr\n\n::: {.cell}\n\n```{.r .cell-code}\noecd |> \ngghistogram(x = \"Life_satisfaction\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n### Mit DataExplorer\n\n::: {.cell}\n\n```{.r .cell-code}\noecd |> \n  select(Life_satisfaction) |> \n  plot_histogram()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n### Mit ggplot\n\nDas R-Paket `ggplot` wird durch das \"Meta-Paket\" `tidyverse` gestartet. Sie müssen es also nicht extra starten.\n\n::: {.cell}\n\n```{.r .cell-code}\noecd %>% \n  ggplot(aes(x = Life_satisfaction)) +\n  geom_histogram()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\nEine ähnliche Aussage liefert das Dichte-Diagramm:\n\n\n::: {.cell}\n\n```{.r .cell-code}\noecd %>% \n  ggplot(aes(x = Life_satisfaction)) +\n  geom_density()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\nDie *Dichte*  gibt an, welcher Anteil der Beobachtungen an der jeweiligen Stelle der X-Achse lägen, wenn man eine Einheit betrachtet (z.B. die Lebenszufriedenheit von 5-6).\n\n\n## Histogramm nach Gruppen: Lebenszufriedenheit in De und Fr\n\nAngenommen, man möchte Deutschland mit Frankreich vergleichen im Hinblick auf die Lebenszufriedenheit.\n\nZunächst filtern wir den OECD-Datensatz, so dass nur die beiden genannten Länder enthalten bleiben:\n\n\n::: {.cell}\n\n```{.r .cell-code}\noecd_de_fr <- \noecd %>% \n  filter(Country == \"Germany\" | Country == \"France\") \n```\n:::\n\n\nDann visualisieren wir wieder.\n\n### Mit ggpubr\n\n::: {.cell}\n\n```{.r .cell-code}\noecd_de_fr |> \n  gghistogram(x = \"Life_satisfaction\", facet.by = \"Country\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n### Mit DataExplorer\n\nLeider unterstützt DataExplorer nicht direkt den Vergleich von Grupen mit einem Histogramm. Man könnte aber einen Boxplot verwenden stattdessen.\n\n::: {.cell}\n\n```{.r .cell-code}\noecd_de_fr |> \n  select(Life_satisfaction, Country) |> \n  plot_boxplot(by = \"Country\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n### Mit ggplot\n\n::: {.cell}\n\n```{.r .cell-code}\noecd_de_fr %>% \n  ggplot(aes(x = Life_satisfaction)) +\n  geom_histogram(bins = 15) +\n  facet_wrap(~ Country)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n\n## Histogramm für alle metrischen Variablen auf einmal\n\nUm einen Überblick über die Verteilungen zu bekommen, bietet es sich an, sich alle Verteilungen anzuschauen. \nMalen wir einmal alle Histogramme auf einmal. Das geht wiederum mit `DataExplorer` sehr einfach:\n\n::: {.cell}\n\n```{.r .cell-code}\noecd |> \n  plot_histogram()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n:::\n\n\n\n## VERTIEFUNG: Histogramm für alle Variablen auf kompliziert\n\n\n\n:::{.callout-note}\nDieser Abschnitt ist eine Vertiefung; Sie können in überspringen, ohne den Anschluss zu den folgenden Abschnitten zu verlieren. $\\square$\n:::\n\n\n\n\nAls erstes erzeugen wir einen langen Dataframe (der nur aus metrischen Variablen besteht):\n\n::: {.cell}\n\n```{.r .cell-code}\noecd_de_fr %>% \n  select(where(is.numeric)) %>%  # wähle alle Spalten aus, wo sich Nummern finden\n  pivot_longer(everything()) %>%  # baue alle Variablen in ein langes Format um\n  slice(1:10) # zeige die Zeilen 1 bis 10\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10 × 2\n   name                     value\n   <chr>                    <dbl>\n 1 Education                  7.8\n 2 Jobs                       6  \n 3 Income                     6.3\n 4 Safety                     8.6\n 5 Health                    10  \n 6 Environment                3.5\n 7 Civic_engagement           7.4\n 8 Accessiblity_to_services   8.6\n 9 Housing                    3.3\n10 Community                  7.9\n```\n\n\n:::\n:::\n\n\n\nDann plotten wir Histogramme, wobei wir nach den Ländern (`key`) gruppieren. Aber zuerst speichern wir uns den \"langen\" Datensatz ab:\n\n::: {.cell}\n\n```{.r .cell-code}\noecd_de_fr_long <- \noecd_de_fr %>% \n  select(where(is.numeric)) %>%  # wähle alle Spalten aus, wo sich Nummern finden\n  pivot_longer(everything()) \n```\n:::\n\nBetrachten Sie diesen Daten einmal zur Übung.\n\n\nDann plotten wir in gewohnter Manier:\n\n::: {.cell}\n\n```{.r .cell-code}\noecd_de_fr_long %>% \n  ggplot(aes(x = value)) +\n  geom_histogram() +\n  facet_wrap(~ name)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n:::\n\n\n\n\n\n# Forschungsfrage: Lebenszufriedenheit in De im internationalen Vergleich\n\n## Hintergrund\n\nHat Deutschland in Vergleich zu anderen Ländern eine hohe Lebenszufriedenheit?\n\nDie Frage ist noch recht unpräzise formuliert, aber dafür gibt sie Raum für eine Menge von Untersuchungsansätzen.\n\n\n### Datensatz filtern - nur Länder, keine Landesteile\n\nDer Datensatz in seiner aktuellen Form verstößt gegen die Regel der \"Normalform\", dass in jeder Zeile (genau) eine Beobachtungseinheit steht und in jeder Zeile (genau) eine Variable. In einigen Zeilen stehen *Länder*, in den meisten anderen aber *Landesteile* (wie Bayern, Baden-Württemberg etc.). Filtern wir uns nur die Länder, und exkdluieren die Landesteile:\n\n\n::: {.cell}\n\n```{.r .cell-code}\noecd_short <-\n  filter(oecd, region_type == \"country_whole\") \n```\n:::\n\nDie Anzahl der Zeilen dieses Datensatz `oecd_short` gibt uns Aufschluss über die Anzahl der untersuchten Länder.\n\n\n### Visualisierung der Lebenszufriedenheit der Länder\n\n\n#### Mit DataExplorer\n\n::: {.cell}\n\n```{.r .cell-code}\noecd_short |> \n  select(Country, Life_satisfaction) |> \n  plot_scatterplot(by = \"Life_satisfaction\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n:::\n\n\n#### Mit ggplot\n\n::: {.cell}\n\n```{.r .cell-code}\noecd_short %>% \n  ggplot(aes(x = Country, y = Life_satisfaction)) +\n  geom_point()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-18-1.png){width=672}\n:::\n:::\n\n\n#### Sieht nicht so schön aus\n\nHm, unser Punktediagramm sieht nicht übersichtlich aus. Besser wäre es, die Punkte absteigend zu sortieren.\n\nBetrachten wir dazu die Variable `country` näher: Es handelt sich um eine Character-Variable:\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(oecd)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n'data.frame':\t429 obs. of  15 variables:\n $ Country                 : chr  \"Australia\" \"Australia\" \"Australia\" \"Australia\" ...\n $ Region                  : chr  \"New South Wales\" \"Victoria\" \"Queensland\" \"South Australia\" ...\n $ region_type             : chr  \"country_part\" \"country_part\" \"country_part\" \"country_part\" ...\n $ Code                    : chr  \"AU1\" \"AU2\" \"AU3\" \"AU4\" ...\n $ Education               : num  8 8.1 7.8 7.3 7.6 6.5 8.1 9.5 8.8 8.5 ...\n $ Jobs                    : num  8.1 7.9 8.1 7.8 8.8 7.6 8.7 9.3 7.8 8.2 ...\n $ Income                  : num  6.8 5.9 6.3 6.1 7.9 5.4 8.2 10 5.7 5.9 ...\n $ Safety                  : num  8.8 9.5 9.5 9 8.6 8.8 0 10 9.7 9.8 ...\n $ Health                  : num  9 9.5 8.3 8.5 9.3 5.4 2.4 9.3 6.7 6.6 ...\n $ Environment             : num  9.8 8.6 9.9 9.4 9.6 10 9.2 9.1 3.5 2.6 ...\n $ Civic_engagement        : num  10 10 10 10 10 10 8.4 10 8.6 8.1 ...\n $ Accessiblity_to_services: num  7.2 7.5 7.7 7.2 7.8 6.8 7.8 8.7 8 7.4 ...\n $ Housing                 : num  7.2 7.8 8.3 8.3 8.9 8.3 5.6 8.3 6.1 5.6 ...\n $ Community               : num  8.9 9.3 8.6 8.6 8.5 8.6 10 9.8 8.3 7.8 ...\n $ Life_satisfaction       : num  7.8 8.5 8.1 8.5 7.8 9.6 7 9.6 7.8 8.1 ...\n```\n\n\n:::\n:::\n\nEine Variable des Typs `character` steht für Text, z.B. `\"Germany\"`.\n\nOffensichtlich sind diese alphabetisch geordnet -- nach dieser Ordnung richtet sich die Ordnung im Diagramm.\n\n\n### Umwandling in eine Faktor-Variable\n\nIn solchen Fällen bietet es sich an, die Character-Variable in eine *Factor-Variable* umzuwandeln; dann geht das Weitere einfacher.\n\n\n::: {.cell}\n\n```{.r .cell-code}\noecd_short <- \noecd_short %>% \n  mutate(Country = factor(Country))\n```\n:::\n\nÜbrigens:\nMöchte man wissen, wie viele *unterschiedliche* Werte eine Variable enthält, dann kann die Funktion `distinct()` verwenden:\n\n::: {.cell}\n\n```{.r .cell-code}\noecd_short %>% \n  distinct(Country)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           Country\n1        Australia\n2          Austria\n3          Belgium\n4           Canada\n5            Chile\n6   Czech Republic\n7          Denmark\n8          Estonia\n9          Finland\n10          France\n11         Germany\n12          Greece\n13         Hungary\n14         Iceland\n15         Ireland\n16          Israel\n17           Italy\n18           Japan\n19           Korea\n20      Luxembourg\n21          Mexico\n22     Netherlands\n23     New Zealand\n24          Norway\n25          Poland\n26        Portugal\n27 Slovak Republic\n28        Slovenia\n29           Spain\n30          Sweden\n31     Switzerland\n32          Turkey\n33  United Kingdom\n34   United States\n```\n\n\n:::\n:::\n\n\n\n## Ranking und Top-10-Prozent der Zufriedenheit\n\n### Top-10\n\nSchauen wir uns die \"Happy-Top-10\" an, die 10 Länder mit der höchsten Lebenszufriedenheit:\n\n\n::: {.cell}\n\n```{.r .cell-code}\noecd_short %>% \n  arrange(-Life_satisfaction) %>%  # absteigend sortieren\n  select(Country, Life_satisfaction) %>% \n  slice(1:10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       Country Life_satisfaction\n1      Denmark              10.0\n2  Switzerland              10.0\n3      Finland               9.7\n4  Netherlands               9.7\n5       Norway               9.7\n6       Canada               9.3\n7      Iceland               9.3\n8       Sweden               9.3\n9    Australia               8.8\n10     Austria               8.8\n```\n\n\n:::\n:::\n\n### Die oberen 10% der Zufriedenheit\n\nMit welcher Lebenszufriedenheit gehört ein Land zu den Top-10-Prozent der zufriedenen Länder?\n\n::: {.cell}\n\n```{.r .cell-code}\noecd_short %>% \n  summarise(quantile(Life_satisfaction, probs = .90))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  quantile(Life_satisfaction, probs = 0.9)\n1                                      9.7\n```\n\n\n:::\n:::\n\n\nAh, Länder mit einer Lebenszufriedenheit von mind. 9.7 gehören zu den oberen Top-10-Prozent. \nFiltern wir mal entsprechend:\n\n\n::: {.cell}\n\n```{.r .cell-code}\noecd_short %>% \n  filter(Life_satisfaction >= 9.7) %>% \n  select(Country, Life_satisfaction)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      Country Life_satisfaction\n1     Denmark              10.0\n2     Finland               9.7\n3 Netherlands               9.7\n4      Norway               9.7\n5 Switzerland              10.0\n```\n\n\n:::\n:::\n\n\n\n## Vertiefung\n\nÄndern wir die Sortierung! Mit `reorder()` kann man die Sortierung ändern (re-ordnen, daher der Name):\n\n::: {.cell}\n\n```{.r .cell-code}\noecd_short_reordered <- \noecd_short %>% \n  mutate(Country_sorted = reorder(Country, Life_satisfaction)) \n```\n:::\n\n\nIst das jetzt geordnet? `str()` (wie `str`ucture) verrät es uns:\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(oecd_short_reordered)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n'data.frame':\t34 obs. of  16 variables:\n $ Country                 : Factor w/ 34 levels \"Australia\",\"Austria\",..: 1 2 3 4 5 6 7 8 9 10 ...\n $ Region                  : chr  \"Australia\" \"Austria\" \"Belgium\" \"Canada\" ...\n $ region_type             : chr  \"country_whole\" \"country_whole\" \"country_whole\" \"country_whole\" ...\n $ Code                    : chr  \"AUS\" \"AUT\" \"BEL\" \"CAN\" ...\n $ Education               : num  7.6 8.4 7.5 9.2 7.2 10 6.7 9.6 8.7 7.6 ...\n $ Jobs                    : num  7.9 7.7 5 6.6 6.2 7.3 7.9 6.6 6.4 5.2 ...\n $ Income                  : num  9.5 7.9 6.2 7.4 0.4 2.8 5.1 1 5.6 7 ...\n $ Safety                  : num  8.4 10 5.7 6.5 0.6 6.1 10 0 10 8.4 ...\n $ Health                  : num  9 7.2 6.6 8.5 4.2 2.7 5.8 2.1 7.3 9.3 ...\n $ Environment             : num  9.7 2.8 1.9 7.4 8.5 1.4 5.8 6.4 7.9 4.5 ...\n $ Civic_engagement        : num  10 6.2 9.7 4.7 0.1 2.6 8.9 3.7 4.8 7.5 ...\n $ Accessiblity_to_services: num  6.9 7.2 7.6 8.1 0 6.7 8.3 7.6 9 6.9 ...\n $ Housing                 : num  9.5 5.1 8.8 10 1.5 2.9 6.6 1.5 6.6 5.1 ...\n $ Community               : num  8.8 7.6 7.7 8.5 2.5 5.1 9.6 4.6 8.7 7.6 ...\n $ Life_satisfaction       : num  8.8 8.8 7.9 9.3 4.9 5.3 10 0.4 9.7 6.2 ...\n $ Country_sorted          : Factor w/ 34 levels \"Hungary\",\"Portugal\",..: 23 24 20 27 12 13 33 4 30 15 ...\n  ..- attr(*, \"scores\")= num [1:34(1d)] 8.8 8.8 7.9 9.3 4.9 5.3 10 0.4 9.7 6.2 ...\n  .. ..- attr(*, \"dimnames\")=List of 1\n  .. .. ..$ : chr [1:34] \"Australia\" \"Austria\" \"Belgium\" \"Canada\" ...\n```\n\n\n:::\n:::\n\n\nWie man sieht, ist `Country_sorted` jetzt anders sortiert.\n\nVisualisieren wir das Ergebnis:\n\n\n### Mit DataExplorer\n\n::: {.cell}\n\n```{.r .cell-code}\noecd_short_reordered |> \n  select(Country_sorted, Life_satisfaction) |> \n  plot_scatterplot(by = \"Life_satisfaction\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-27-1.png){width=672}\n:::\n:::\n\nOh, `DataExplorer` macht die Reihenfolge wieder kaputt.\n\n### Mit ggpubr\n\n::: {.cell}\n\n```{.r .cell-code}\noecd_short_reordered |> \n  ggscatter(x = \"Country_sorted\",\n            y = \"Life_satisfaction\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-28-1.png){width=672}\n:::\n:::\n\n\n\n### Mit ggplot\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_sorted <- oecd_short_reordered %>% \n  ggplot(aes(x = Country_sorted, y = Life_satisfaction)) +\n  geom_point()\n\nplot_sorted\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-29-1.png){width=672}\n:::\n:::\n\nSchon besser. Man kann z.B. die Achsen nicht lesen 😭. Was könnte man da bloß tun?\n\n\n### Achsenu um 90 Grad drehen\n\nMit `+ coord_flip()` lassen sich die Achsen um 90 Grad drehen:\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_sorted + coord_flip()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-30-1.png){width=672}\n:::\n:::\n\n\nSchön 😄.\n\nMan hätte das Sortieren und Achsen drehen auch in einem Haps machen können:\n\n\n::: {.cell}\n\n```{.r .cell-code}\noecd_short_reordered %>% \n  ggplot(aes(x = Country_sorted, y = Life_satisfaction)) +\n  geom_point() + coord_flip()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-31-1.png){width=672}\n:::\n:::\n\n\nAber übersichtlicher ist es, die Dinge nacheinander zu tun.\n\n\n### Mittelwert ins Diagramm\n\nSchön wäre es noch, im Bild den Mittelwert o.Ä. im Diagramm zu sehen:\n\n::: {.cell}\n\n```{.r .cell-code}\noecd_short_reordered %>% \n  ggplot(aes(x = Country_sorted, y = Life_satisfaction)) +\n  geom_point() +\n  geom_hline(yintercept = 6.08, data = NA, color = \"firebrick\") + \n  coord_flip()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-32-1.png){width=672}\n:::\n:::\n\nTja, die Wünsche hören nie auf... Wäre es nicht noch nett, wenn \"Deutschland\" hervorgehoben wäre, optisch, so dass es im Diagramm hervorsticht. Nehmen wir an, wir sind an diesem Land besonders interessiert.\n\n::: {.cell}\n\n```{.r .cell-code}\noecd_short_reordered <- \n  oecd_short_reordered %>% \n  mutate(is_Germany = Country == \"Germany\")\n```\n:::\n \nDamit haben wir eine Spalte erstellt, die angibt, ob ein Land Deutschland ist (`TRUE`) oder nicht (`FALSE`). Diese neue Variable nehmen wir her, um die Farbe, Größe und Form der Punkte zu bestimmen:\n \n::: {.cell}\n\n```{.r .cell-code}\noecd_short_reordered %>% \n  ggplot(aes(x = Country_sorted, y = Life_satisfaction)) +\n  geom_point(aes(color = is_Germany, shape = is_Germany, size = is_Germany)) +\n  geom_hline(yintercept = 6.08, data = NA, color = \"firebrick\") + \n  geom_hline(yintercept = 6.08, data = NA, color = \"grey60\") %>% \n  geom_vline(xintercept = 16, data = NA, color = \"grey80\") +\n  coord_flip()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-34-1.png){width=672}\n:::\n:::\n\n\n\n\n## Zusammenhang zweier metrischer Variablen -- Punktediagramm\n\nHängt die Lebenszufriedenheit mit `Civic_engagment` zusammen?\n\nVisualisieren wir diesen (möglichen) Zusammenhang.\n\n### Mit ggpubr\n\n::: {.cell}\n\n```{.r .cell-code}\noecd_short_reordered |> \n  ggscatter(x = \"Civic_engagement\",\n            y = \"Life_satisfaction\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-35-1.png){width=672}\n:::\n:::\n\n\n### Mit DataExplorer\n\n::: {.cell}\n\n```{.r .cell-code}\noecd_short_reordered |> \n  select(Civic_engagement, Life_satisfaction) |> \n  plot_scatterplot(by = \"Life_satisfaction\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-36-1.png){width=672}\n:::\n:::\n\nDataExplorer bietet den Vorteil, dass man einfach überprüfen kann, ob irgendeine Variable mit Lebenszufriedenheit zusammenhängt:\n\n::: {.cell}\n\n```{.r .cell-code}\noecd_short_reordered |> \n  #select(Civic_engagement, Life_satisfaction) |> \n  plot_scatterplot(by = \"Life_satisfaction\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-37-1.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-37-2.png){width=672}\n:::\n:::\n\n\n### Mit ggplot\n\n\n::: {.cell}\n\n```{.r .cell-code}\noecd_short_reordered %>% \n  ggplot(aes(x = Civic_engagement, y = Life_satisfaction)) +\n  geom_point()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-38-1.png){width=672}\n:::\n:::\n\n### Insgesamt wenig Zusammenhang\n\nHm, es ist kein starker Trend zu erkennen.\n\nWas sagt die Korrelation dazu:\n\n::: {.cell}\n\n```{.r .cell-code}\noecd_short_reordered %>% \n  summarise(cor_ce_ls = cor(Civic_engagement, Life_satisfaction))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  cor_ce_ls\n1 0.4021292\n```\n\n\n:::\n:::\n\nImmerhin, kein ganz unwesentlicher Wert.\n\n\n### Und so weiter\n\nDieses Prinzip mit dem Punktediagramm könnte man jetzt weiterführen ad nauseam.\n\n\n### Korrelationsdiagramm\n\n\n::: {.cell}\n\n```{.r .cell-code}\noecd_short_reordered |> \n  plot_correlation()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-40-1.png){width=672}\n:::\n:::\n\n\n## Zusammenhang zweier Variablen unter Berücksichtigung von Drittvariablen\n\nOben haben wir gesehen, dass Lebenszufriedenheit und Civiv Engagement zusammenhängen (zumindest ein bisschen).\n\nAber vielleicht hängt dieser Zusammenhang wiederum von der finanziellen Absicherung ab? Nur wenn man materiell abgesichert ist, so könnte man argumentieren, wird bürgerliches Engagement (bzw. die Möglichkeit zu) eine Einflussgröße auf die Lebenszufriedenheit.\n\nAnders gesagt: Man könnte behaupten, der Zusammenahng von Lebenszufriedenheit und Civiv Engagement ist abhängig von einer dritten Variable, dem Einkommen.\n\nUm diese Frage zu untersuchen, teilen wir `Income` in zwei Stufen, hoch und gering. Dann untersuchen wir jeweils den Zusammenhang von Lebenszufriedenheit und bürgerlichem Engagement.\n\n*Achtung*! Eine metrische Variablen in zwei Hälften zu spalten birgt einen hohen Informationsverlust. Da wir aber nur eine grobe Untersuchung vorhaben (und uns noch nicht fortgeschrittener Technik bedienen wollen), bleiben wir erstmal bei dieser sog. *Dichotomisierung*.\n\nNehmen wir den Median des Einkommen als Teilungspunkt; man spricht von einem \"Mediansplit\":\n\n::: {.cell}\n\n```{.r .cell-code}\noecd_short %>% \n  summarise(Income_md = median(Income))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Income_md\n1      5.15\n```\n\n\n:::\n:::\n\n\n\nZuerst erstellen wir eine Variable `Income_high` mit den Stufen 0 (nein) und 1 (ja):\n\n::: {.cell}\n\n```{.r .cell-code}\noecd_short_reordered <- \n  oecd_short_reordered %>% \n    mutate(Income_high = \n           case_when( Income >= median(Income) ~ 1,\n                      Income < median(Income) ~ 0))\n```\n:::\n\n\n### Visualisierung\n\nJetzt plotten wir den Zusammenhang:\n\n\n\n#### Mit ggpubr\n\n::: {.cell}\n\n```{.r .cell-code}\noecd_short_reordered |> \n  ggscatter(y = \"Country_sorted\",\n            x = \"Life_satisfaction\",\n            facet.by = \"Income_high\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-43-1.png){width=672}\n:::\n:::\n\n\n\n#### Mit ggplot\n\n::: {.cell}\n\n```{.r .cell-code}\nincome_labels <- c(`0` = \"arm\", \n                   `1` =\"reich\")\n\noecd_short_reordered %>% \n  ggplot(aes(x = Country_sorted, y = Life_satisfaction)) +\n  geom_point() +\n  facet_wrap(~ Income_high, \n             labeller = labeller(Income_high = income_labels))  +\n  coord_flip() +\n  labs(y = \"Länder\",\n       x = \"Lebenszufriedenheit\",\n       title = \"Lebenszufriedenheit in armen und reichen Ländern \") +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-44-1.png){width=672}\n:::\n:::\n\n\n### Vertiefung: Korrelation pro Gruppe\n\nUm die Korrelation pro Gruppe zu erhalten, könnten wir jeweils einen Dataframe pro Gruppe erzeugen (mit `filter()`) und dann jeweils die Korrelation von Zufriedenheit und Engagement berechnen.\n\nEine andere, etwas elegantere Möglichkeit kann so aussehen:\n\n::: {.cell}\n\n```{.r .cell-code}\noecd_short_reordered %>%\n  group_by(Income_high) %>% \n  summarise(cor_zuf_eng = cor(Life_satisfaction, Civic_engagement))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 2\n  Income_high cor_zuf_eng\n        <dbl>       <dbl>\n1           0       0.367\n2           1       0.140\n```\n\n\n:::\n:::\n\nInteressanterweise ist die Korrelation durchaus verschieden in den beiden Gruppen.\n\nNatürlich sind die beiden Gruppen nur Stichproben - es stellt sich die Frage, ob die Unterschiede nur durch Zufälligkeiten des Stichprobenziehens entstanden sind oder auch in der Grundgesatmtheit der \"reichen\" und \"armen\" Ländern existieren? Dazu später mehr!\n\n\n## Deskriptive Statistiken nach Ländern\n \n \n### Lebenszufriedenheit\n\n#### Mit `easystats`\n\nDas ist relativ einfach:\n\n::: {.cell}\n\n```{.r .cell-code}\noecd_short_reordered %>% \n  select(Life_satisfaction) %>% \n  describe_distribution()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nVariable          | Mean |   SD |  IQR |         Range | Skewness | Kurtosis |  n | n_Missing\n---------------------------------------------------------------------------------------------\nLife_satisfaction | 6.07 | 3.38 | 6.33 | [0.00, 10.00] |    -0.58 |    -1.08 | 34 |         0\n```\n\n\n:::\n:::\n\n\n#### Mit `tidyverse` \n\n::: {.cell}\n\n```{.r .cell-code}\noecd_short_reordered %>% \n  summarise(satis_mean = mean(Life_satisfaction),\n            satis_median = median(Life_satisfaction),\n            satis_sd = sd(Life_satisfaction),\n            satis_iqr = IQR(Life_satisfaction))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  satis_mean satis_median satis_sd satis_iqr\n1   6.070588          7.3 3.379397     5.975\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n# Reproducibility\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n─ Session info ───────────────────────────────────────────────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.2.1 (2022-06-23)\n os       macOS Big Sur ... 10.16\n system   x86_64, darwin17.0\n ui       X11\n language (EN)\n collate  en_US.UTF-8\n ctype    en_US.UTF-8\n tz       Europe/Berlin\n date     2024-05-09\n pandoc   3.1.12.2 @ /usr/local/bin/ (via rmarkdown)\n\n─ Packages ───────────────────────────────────────────────────────────────────────────────────────────────────────────\n package      * version    date (UTC) lib source\n abind          1.4-5      2016-07-21 [1] CRAN (R 4.2.0)\n assertthat     0.2.1      2019-03-21 [1] CRAN (R 4.2.0)\n backports      1.4.1      2021-12-13 [1] CRAN (R 4.2.0)\n bayestestR   * 0.13.2     2024-02-12 [1] CRAN (R 4.2.1)\n broom          1.0.5      2023-06-09 [1] CRAN (R 4.2.0)\n cachem         1.0.8      2023-05-01 [1] CRAN (R 4.2.0)\n callr          3.7.5      2024-02-19 [1] CRAN (R 4.2.1)\n car            3.1-2      2023-03-30 [1] CRAN (R 4.2.0)\n carData        3.0-5      2022-01-06 [1] CRAN (R 4.2.0)\n cli            3.6.2      2023-12-11 [1] CRAN (R 4.2.0)\n coda           0.19-4     2020-09-30 [1] CRAN (R 4.2.0)\n codetools      0.2-19     2023-02-01 [1] CRAN (R 4.2.0)\n colorspace     2.1-0      2023-01-23 [1] CRAN (R 4.2.0)\n correlation  * 0.8.4      2023-04-06 [1] CRAN (R 4.2.1)\n crayon         1.5.2      2022-09-29 [1] CRAN (R 4.2.1)\n data.table     1.14.10    2023-12-08 [1] CRAN (R 4.2.0)\n DataExplorer * 0.8.2      2020-12-15 [1] CRAN (R 4.2.0)\n datawizard   * 0.9.1      2023-12-21 [1] CRAN (R 4.2.0)\n devtools       2.4.5      2022-10-11 [1] CRAN (R 4.2.1)\n digest         0.6.33     2023-07-07 [1] CRAN (R 4.2.0)\n dplyr        * 1.1.4      2023-11-17 [1] CRAN (R 4.2.0)\n easystats    * 0.7.0      2023-11-05 [1] CRAN (R 4.2.1)\n effectsize   * 0.8.6      2023-09-14 [1] CRAN (R 4.2.0)\n ellipsis       0.3.2      2021-04-29 [1] CRAN (R 4.2.0)\n emmeans        1.8.9      2023-10-17 [1] CRAN (R 4.2.0)\n emo            0.0.0.9000 2023-05-22 [1] Github (hadley/emo@3f03b11)\n estimability   1.4.1      2022-08-05 [1] CRAN (R 4.2.0)\n evaluate       0.23       2023-11-01 [1] CRAN (R 4.2.0)\n fansi          1.0.6      2023-12-08 [1] CRAN (R 4.2.0)\n farver         2.1.1      2022-07-06 [1] CRAN (R 4.2.0)\n fastmap        1.1.1      2023-02-24 [1] CRAN (R 4.2.0)\n forcats      * 1.0.0      2023-01-29 [1] CRAN (R 4.2.0)\n fs             1.6.3      2023-07-20 [1] CRAN (R 4.2.0)\n generics       0.1.3      2022-07-05 [1] CRAN (R 4.2.0)\n ggformula    * 0.12.0     2023-11-09 [1] CRAN (R 4.2.0)\n ggplot2      * 3.5.0      2024-02-23 [1] CRAN (R 4.2.1)\n ggpubr       * 0.6.0      2023-02-10 [1] CRAN (R 4.2.0)\n ggridges     * 0.5.6      2024-01-23 [1] CRAN (R 4.2.1)\n ggsignif       0.6.4      2022-10-13 [1] CRAN (R 4.2.0)\n glue           1.6.2      2022-02-24 [1] CRAN (R 4.2.0)\n gridExtra      2.3        2017-09-09 [1] CRAN (R 4.2.0)\n gtable         0.3.4      2023-08-21 [1] CRAN (R 4.2.0)\n haven          2.5.4      2023-11-30 [1] CRAN (R 4.2.0)\n hms            1.1.3      2023-03-21 [1] CRAN (R 4.2.0)\n htmltools      0.5.7      2023-11-03 [1] CRAN (R 4.2.0)\n htmlwidgets    1.6.4      2023-12-06 [1] CRAN (R 4.2.0)\n httpuv         1.6.13     2023-12-06 [1] CRAN (R 4.2.0)\n igraph         2.0.2      2024-02-17 [1] CRAN (R 4.2.1)\n insight      * 0.19.8     2024-01-31 [1] CRAN (R 4.2.1)\n jsonlite       1.8.8      2023-12-04 [1] CRAN (R 4.2.0)\n knitr          1.45       2023-10-30 [1] CRAN (R 4.2.1)\n labeling       0.4.3      2023-08-29 [1] CRAN (R 4.2.0)\n labelled       2.11.0     2023-04-11 [1] CRAN (R 4.2.0)\n later          1.3.2      2023-12-06 [1] CRAN (R 4.2.0)\n lattice      * 0.21-8     2023-04-05 [1] CRAN (R 4.2.0)\n lifecycle      1.0.4      2023-11-07 [1] CRAN (R 4.2.1)\n lubridate    * 1.9.3      2023-09-27 [1] CRAN (R 4.2.0)\n magrittr       2.0.3      2022-03-30 [1] CRAN (R 4.2.0)\n MASS           7.3-60     2023-05-04 [1] CRAN (R 4.2.0)\n Matrix       * 1.5-4.1    2023-05-18 [1] CRAN (R 4.2.0)\n memoise        2.0.1      2021-11-26 [1] CRAN (R 4.2.0)\n mime           0.12       2021-09-28 [1] CRAN (R 4.2.0)\n miniUI         0.1.1.1    2018-05-18 [1] CRAN (R 4.2.0)\n modelbased   * 0.8.7      2024-02-15 [1] CRAN (R 4.2.1)\n mosaic         1.9.0      2023-11-10 [1] CRAN (R 4.2.1)\n mosaicCore     0.9.4.0    2023-11-05 [1] CRAN (R 4.2.1)\n mosaicData   * 0.20.4     2023-11-05 [1] CRAN (R 4.2.1)\n multcomp       1.4-25     2023-06-20 [1] CRAN (R 4.2.0)\n munsell        0.5.0      2018-06-12 [1] CRAN (R 4.2.0)\n mvtnorm        1.2-2      2023-06-08 [1] CRAN (R 4.2.0)\n networkD3      0.4        2017-03-18 [1] CRAN (R 4.2.0)\n parameters   * 0.21.5     2024-02-07 [1] CRAN (R 4.2.1)\n performance  * 0.10.9     2024-02-17 [1] CRAN (R 4.2.1)\n pillar         1.9.0      2023-03-22 [1] CRAN (R 4.2.0)\n pkgbuild       1.4.0      2022-11-27 [1] CRAN (R 4.2.0)\n pkgconfig      2.0.3      2019-09-22 [1] CRAN (R 4.2.0)\n pkgload        1.3.2.1    2023-07-08 [1] CRAN (R 4.2.0)\n plyr           1.8.8      2022-11-11 [1] CRAN (R 4.2.0)\n prettyunits    1.2.0      2023-09-24 [1] CRAN (R 4.2.0)\n processx       3.8.3      2023-12-10 [1] CRAN (R 4.2.0)\n profvis        0.3.8      2023-05-02 [1] CRAN (R 4.2.0)\n promises       1.2.1      2023-08-10 [1] CRAN (R 4.2.0)\n ps             1.7.5      2023-04-18 [1] CRAN (R 4.2.0)\n purrr        * 1.0.2      2023-08-10 [1] CRAN (R 4.2.0)\n R6             2.5.1      2021-08-19 [1] CRAN (R 4.2.0)\n Rcpp           1.0.11     2023-07-06 [1] CRAN (R 4.2.0)\n readr        * 2.1.5      2024-01-10 [1] CRAN (R 4.2.1)\n remotes        2.4.2.1    2023-07-18 [1] CRAN (R 4.2.0)\n report       * 0.5.8      2023-12-07 [1] CRAN (R 4.2.1)\n reshape2       1.4.4      2020-04-09 [1] CRAN (R 4.2.0)\n rlang          1.1.3      2024-01-10 [1] CRAN (R 4.2.1)\n rmarkdown      2.26       2024-03-05 [1] CRAN (R 4.2.1)\n rstatix        0.7.2      2023-02-01 [1] CRAN (R 4.2.0)\n rstudioapi     0.15.0     2023-07-07 [1] CRAN (R 4.2.0)\n sandwich       3.0-2      2022-06-15 [1] CRAN (R 4.2.0)\n scales       * 1.3.0      2023-11-28 [1] CRAN (R 4.2.0)\n see          * 0.8.2      2024-02-14 [1] CRAN (R 4.2.1)\n sessioninfo    1.2.2      2021-12-06 [1] CRAN (R 4.2.0)\n shiny          1.8.0      2023-11-17 [1] CRAN (R 4.2.1)\n stringi        1.8.3      2023-12-11 [1] CRAN (R 4.2.0)\n stringr      * 1.5.1      2023-11-14 [1] CRAN (R 4.2.1)\n survival       3.5-5      2023-03-12 [1] CRAN (R 4.2.0)\n TH.data        1.1-2      2023-04-17 [1] CRAN (R 4.2.0)\n tibble       * 3.2.1      2023-03-20 [1] CRAN (R 4.2.0)\n tidyr        * 1.3.1      2024-01-24 [1] CRAN (R 4.2.1)\n tidyselect     1.2.0      2022-10-10 [1] CRAN (R 4.2.0)\n tidyverse    * 2.0.0      2023-02-22 [1] CRAN (R 4.2.0)\n timechange     0.2.0      2023-01-11 [1] CRAN (R 4.2.0)\n tzdb           0.4.0      2023-05-12 [1] CRAN (R 4.2.0)\n urlchecker     1.0.1      2021-11-30 [1] CRAN (R 4.2.0)\n usethis        2.2.2      2023-07-06 [1] CRAN (R 4.2.0)\n utf8           1.2.4      2023-10-22 [1] CRAN (R 4.2.0)\n vctrs          0.6.5      2023-12-01 [1] CRAN (R 4.2.0)\n withr          3.0.0      2024-01-16 [1] CRAN (R 4.2.1)\n xfun           0.41       2023-11-01 [1] CRAN (R 4.2.0)\n xtable         1.8-4      2019-04-21 [1] CRAN (R 4.2.0)\n yaml           2.3.8      2023-12-11 [1] CRAN (R 4.2.0)\n zoo            1.8-12     2023-04-13 [1] CRAN (R 4.2.0)\n\n [1] /Users/sebastiansaueruser/Rlibs\n [2] /Library/Frameworks/R.framework/Versions/4.2/Resources/library\n\n──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n```\n\n\n:::\n:::\n\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}