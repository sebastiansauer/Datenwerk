{
  "hash": "979f767f790a125261afa9886df7960d",
  "result": {
    "engine": "knitr",
    "markdown": "---\ndate: 2024-06-29\ndraft: FALSE   # ACHTUNG DRAFT STEHT AUF TRUE!\ntitle: flights-delay-simplified\nexecute: \n  eval: true \n  cache: true\n  freeze: true\nhighlight-style: arrow \ncache: true\ntoc: true\nnumber-sections: true\nextype: string\nexsolution: \"\"\nexshuffle: no\ncategories:\n- lm  # ENTER CATEGORIES HERE\n- regression\n- interaction\n- yacsda\n---\n\n\n\n\n\n\n# Hintergrund und Forschungsfrage\n\n\nWir untersuchen die Forschungsfrage *Was sind Prädiktoren von Flugverspätungen*. \nWir nutzen `dep_delay` als AV (Zielvariable), also als die Variable, die wir vorhersagen wollen.\n\nDazu verwenden wir lineare Modelle als Modellierungsmethoden.\n\n\n# Ressourcen und Vertiefung\n\nDieser Post knüpft an [den Post zur explorativen Datenanalyse der Flugverspätungen](https://data-se.netlify.app/2021/03/08/eda-zu-flugversp%C3%A4tungen/) an (es gibt auch [hier, Teil 1](https://www.youtube.com/watch?v=t8i_qTonuLM) und [hier, Teil 2](https://youtu.be/AeBqwr2U7MA) ein Video zu diesem EDA-Post).\n[Dieser Post](https://datenwerk.netlify.app/posts/flights-delay/) ist eine längere (nicht-verkürzte) Version der vorliegenden Fallstudie.\n\n\n\n# Setup\n\n## Pakete laden\n\nWirklich wichtig sind nur `tidymodels` und `tidyverse`. Die restlichen Pakete werden nur am Rande benötigt. \nMan sollte auch nur die Pakete laden,\ndie man für die Analyse benötigt.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(\"tidymodels\")  # Train- und Test-Sample aufteilen\nlibrary(\"tidyverse\")  # data wrangling\nlibrary(\"conflicted\")  # Name clashes finden\nlibrary(\"easystats\")  # stats made easy\nlibrary(\"DataExplorer\")  # Data Vis\n```\n:::\n\n\n\n\n## Daten laden: Flights 2023\n\nAus Gründen der Datenökonomie nutzen wir eine kleinere Version des Datensatz `flights`. \nWir nutzen nicht mehr die Daten aus dem 2013, sondern die neueren Daten aus dem Jahr 2023.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(nycflights23)\ndata(flights)\n\nset.seed(42)  # Reproduzierbarkeit\nflights <- \n  flights |> \n  sample_n(size = 3e4)  # \"3e4\" heißt \"3 Mal 10 hoch 4\"\n```\n:::\n\n\n\nAchtung: `flights` ist recht groß; die Regressionsmodelle können leicht ein paar Hundert Megabyte groß werden. Das bringt u.U. auch einen modernen Computer irgendwann ins Straucheln.\nDaher verringern wir aus Gründen der Einfachheit den Datensatz mit einem Zufallssample.\nMan beachte, dass die Präzision der Ergebnisse höher ist, wenn man nicht mit einem Zufallssample, sondern dem gesamten Datensatz arbeitet.\n\n\n\n\n\n# flights2: Nicht benötigte Variablen entfernen und ID hinzufügen\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights2 <-\n  flights %>% \n  select(-c(year)) %>%   # \"year\" ist konstant und daher nutzlos\n  drop_na(dep_delay) %>% \n  mutate(id = row_number()) %>%  # ID als fortlaufende Nummer\n  select(id, everything())  # id nach vorne ziehen\n```\n:::\n\n\n\nDie ID hilft uns, einzelne Flüge (Beobachtungen) zu identifizieren, z.B. wenn wir einen bestimmten Flug näher analysieren oder entfernen wolllen.\n\n\nAchtung: Die ID-Variable sollte man nicht als Prädiktor verwenden, da sie keine Information birgt.\n\n# Heimliche AVs entfernen\n\n`dep_delay` ist unsere AV (Zielvariable), die Variable also, die wir vorhersagen.\n\n`arr_delay` ist eine Variable, die uns *nicht* zur Verfügung steht, wenn es um die Vorhersage neuer, noch nicht gestarteter Flüge geht.\nEs wäre daher falsch, unser Modell auf einer Variable zu gründen, auf die wir später (beim Vorhersagen) nicht zurückgreifen können.\nAlso raus damit.\n\nÄhnliches gilt für ein paar andere Variablen:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nheimliche_avs <- c(\"dep_time\", \"arr_time\", \"arr_delay\", \"air_time\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nflights2_ohne_heimliche_avs <-\n  flights2 |> \n  select(-any_of(heimliche_avs))\n```\n:::\n\n\n\n`any_of` ist nur eine Tipphilfe. Man hätte auch direkt die Namen der zu entfernenden Spalten eingeben können, etwa `select(-dep_time, ...)`.\n\nCheck:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames(flights2_ohne_heimliche_avs)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"id\"             \"month\"          \"day\"            \"sched_dep_time\"\n [5] \"dep_delay\"      \"sched_arr_time\" \"carrier\"        \"flight\"        \n [9] \"tailnum\"        \"origin\"         \"dest\"           \"distance\"      \n[13] \"hour\"           \"minute\"         \"time_hour\"     \n```\n\n\n:::\n:::\n\n\nEine vielleicht gute Nachricht ist, dass Sie sich in der Prüfung nicht um diese Frage kümmern müssen.\n\n\n# Aufteilung in Train- und Testsample\n\n\nDer Hintergrund zur Idee der Aufteilung in Train- und Test-Stichprobe kann z.b. [hier](https://www.tmwr.org/splitting.html) oder [hier](https://www.springer.com/de/book/9783658215866), Kapitel 15, nachgelesen werden.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(42)  # Reproduzierbarkeit\nflights_split <- initial_split(flights2_ohne_heimliche_avs, \n                               strata = dep_delay)\n```\n:::\n\n\n\n\n# flights_train2, flights_test2\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(42)  # Reproduzierbarkeit\nflights_train2 <- training(flights_split)\nflights_test2 <- testing(flights_split)\n```\n:::\n\n\n\nDie \"wirkliche Welt\" (was immer das ist) besorgt die Aufteilung von Train- und Test-Sample für Sie automatisch. \nSagen wir, Sie arbeiten für die Flughafen-Aufsicht von New York. \nDann haben Sie einen Erfahrungsschatz an Flügen aus der Vergangenheit in Ihrer Datenbank (Train-Sample). Einige Tages kommt Ihr Chef zu Ihnen und sagt: \"Rechnen Sie mir mal die zu erwartende Verspätung der Flüge *im nächsten Monat* aus!\". \nDa *heute* nicht klar ist, wie die Verspätung der Flüge *in der Zukunft* (nächsten Monat) sein wird, stellen die Flüge des nächsten Monats das Test-Sample dar.\n\nÜbrigens: In der Prüfung besorgt das Aufteilen von Train- und Test-Sample netterweise Ihr Dozent...\n\n\n\nCheck:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames(flights_train2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"id\"             \"month\"          \"day\"            \"sched_dep_time\"\n [5] \"dep_delay\"      \"sched_arr_time\" \"carrier\"        \"flight\"        \n [9] \"tailnum\"        \"origin\"         \"dest\"           \"distance\"      \n[13] \"hour\"           \"minute\"         \"time_hour\"     \n```\n\n\n:::\n:::\n\n\n\n\n# lm0: Nullmodell\n\nEigentlich nicht nötig, das Nullmodell, primär aus didaktischen Gründen berechnet, um zu zeigen, dass in diesem Fall $R^2$ wirklich gleich Null ist.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlm0 <- lm(dep_delay ~ 1, data = flights_train2)\nmodel_parameters(lm0)  # model_parameters zeit die (geschätzten) Regressionsgewichte (Betas)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nParameter   | Coefficient |   SE |         95% CI | t(21918) |      p\n---------------------------------------------------------------------\n(Intercept) |       13.95 | 0.38 | [13.21, 14.69] |    36.91 | < .001\n```\n\n\n:::\n:::\n\n\n\nWir könnten anstatt `model_parameters` auch `parameters` nutzen; das ist der gleiche Befehl.\n\nAllerdings gibt es den Befehl `parameters` in *zwei* Paketen, es käme also zu einem \"Name Clash\".\nDas umgehen wir, indem wir `model_parameter` nutzen, und nicht `parameters`. \n\n# lm1: origin\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlm1 <- lm(dep_delay ~ origin, data = flights_train2)\nmodel_parameters(lm1)  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nParameter    | Coefficient |   SE |         95% CI | t(21916) |      p\n----------------------------------------------------------------------\n(Intercept)  |       15.61 | 0.67 | [14.30, 16.92] |    23.40 | < .001\norigin [JFK] |        0.19 | 0.95 | [-1.68,  2.05] |     0.20 | 0.845 \norigin [LGA] |       -4.64 | 0.91 | [-6.42, -2.85] |    -5.09 | < .001\n```\n\n\n:::\n:::\n\n\n\nMan vergleiche:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights_train2 %>% \n  drop_na(dep_delay) %>% \n  group_by(origin) %>% \n  summarise(delay_avg = mean(dep_delay)) %>% \n  mutate(delay_delta = delay_avg - delay_avg[1])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 3\n  origin delay_avg delay_delta\n  <chr>      <dbl>       <dbl>\n1 EWR         15.6       0    \n2 JFK         15.8       0.186\n3 LGA         11.0      -4.64 \n```\n\n\n:::\n:::\n\n\n\nDer Mittelwertsvergleich und das Modell `lm1` sind faktisch informationsgleich.\n\n\n\nAber leider ist es um die Modellgüte nicht so gut bestellt (eigentlich eher \"grottenschlecht\"):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nr2(lm1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# R2 for Linear Regression\n       R2: 0.002\n  adj. R2: 0.002\n```\n\n\n:::\n:::\n\n\n\n`lm1` ist so schlecht, wir löschen es gleich wieder...\n\n::: {.cell}\n\n```{.r .cell-code}\nrm(lm1)\n```\n:::\n\n\n\n\n# lm2: All in\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# NICHT AUSFÜHREN\n#lm2_all_in <- lm(dep_delay ~ ., data = flights_train2)\n```\n:::\n\n\nModell `lm2_all_in` ist hier *keine* gute Idee, da nominale Prädiktoren in Indikatorvariablen umgewandelt werden. Hat ein nominaler Prädiktor sehr viele Stufen (wie hier), so resultieren sehr viele Indikatorvariablen, was dem Regressionsmodell Probleme bereiten kann (bei mir hängt sich R auf). Besser ist es in dem Fall, die Anzahl der Stufen von nominalskalierten Variablen vorab zu begrenzen.\n\nBei kleineren Datensätzen (weniger Variablen, weniger Fälle) lohnt es sich aber oft, das \"All-in-Modell\" auszuprobieren, als Referenzmaßstab für andere Modelle.\n\n\n\n# lm3: Verlorenes Modell\n\nDieses Modell ging verloren. Wo ist es hin? Wie geht es ihm? Leider gibt es keine Antwort in dieser Fallstudie; aber vielleicht in einer anderen...\n\nEinigen Datensätzen ging es leider ebenso.^[Hintergrund ist, dass diese Fallstudie eine vereinfachte und verkürzte Version einer ähnlichen Fallstudie ist.]\n\n\n# lm4: Alle metrischen Variablen\n\n\nWas sind noch mal unsere metrischen Variablen:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights_train4 <- \nflights_train2 %>% \n  select(where(is.numeric)) |> \n  select(-month, -day, -flight)   # diese Variablen sind nicht wirklich metrisch\n\n\nflights_train4 %>% \n  names()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"id\"             \"sched_dep_time\" \"dep_delay\"      \"sched_arr_time\"\n[5] \"distance\"       \"hour\"           \"minute\"        \n```\n\n\n:::\n:::\n\n\n\nOk, jetzt eine Regression mit diesen Variablen (ober ohne die ID-Variable):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlm4 <- lm(dep_delay ~ ., \n          data = (flights_train4 |> select(-id)))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nr2(lm4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# R2 for Linear Regression\n       R2: 0.016\n  adj. R2: 0.016\n```\n\n\n:::\n:::\n\n\nTja, das $R^2$ hat einen nicht gerade um ...\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel_parameters(lm4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nParameter      | Coefficient |       SE |          95% CI | t(21914) |      p\n-----------------------------------------------------------------------------\n(Intercept)    |       -7.41 |     1.42 | [-10.19, -4.63] |    -5.22 | < .001\nsched dep time |        0.02 |     0.02 | [ -0.01,  0.06] |     1.26 | 0.208 \nsched arr time |   -3.32e-03 | 1.10e-03 | [ -0.01,  0.00] |    -3.01 | 0.003 \ndistance       |    4.03e-03 | 5.36e-04 | [  0.00,  0.01] |     7.53 | < .001\nhour           |       -0.79 |     1.94 | [ -4.59,  3.01] |    -0.41 | 0.683 \n```\n\n\n:::\n:::\n\n\n\nDie Distanz zum Ziel ist offenbar der interessanteste Prädiktor.\n\n\n# flights_train5: Fehlenden Werte ersetzen\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights_train4 |> \n  describe_distribution() |> \n  select(Variable, n_Missing)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nVariable       | n_Missing\n--------------------------\nid             |         0\nsched_dep_time |         0\ndep_delay      |         0\nsched_arr_time |         0\ndistance       |         0\nhour           |         0\nminute         |         0\n```\n\n\n:::\n:::\n\n\nGlücklicherweise haben wir keine fehlende Werte.\n\n\nNur rein zu Übungszwecken: Falls es fehlende Werte gibt,\nman könnte sie z.B. so mit dem Median ersetzen:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights_train5 <-\n  flights_train4 |> \n  mutate(distance = replace_na(distance, median(distance, na.rm = TRUE)))\n```\n:::\n\n\n\n\n# lm6: Wie lm5, aber ohne fehlende Werte\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlm6 <-lm(dep_delay ~ ., data = flights_train5 |> select(-id) )\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nr2(lm6)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# R2 for Linear Regression\n       R2: 0.016\n  adj. R2: 0.016\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel_parameters(lm6)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nParameter      | Coefficient |       SE |          95% CI | t(21914) |      p\n-----------------------------------------------------------------------------\n(Intercept)    |       -7.41 |     1.42 | [-10.19, -4.63] |    -5.22 | < .001\nsched dep time |        0.02 |     0.02 | [ -0.01,  0.06] |     1.26 | 0.208 \nsched arr time |   -3.32e-03 | 1.10e-03 | [ -0.01,  0.00] |    -3.01 | 0.003 \ndistance       |    4.03e-03 | 5.36e-04 | [  0.00,  0.01] |     7.53 | < .001\nhour           |       -0.79 |     1.94 | [ -4.59,  3.01] |    -0.41 | 0.683 \n```\n\n\n:::\n:::\n\n\n\n# flights_train6: Extremwerte entfernen\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights_train5 |> \n  select(where(is.numeric), -id) |> \n  plot_density()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/plot-densities-1.png){width=672}\n:::\n:::\n\n\nEs sieht so aus, als wäre `distance` deutlich rechtsschief mit einigen Ausreißern.\n\nMan könnte auch Boxplots betrachten, die auch gut Extremwerte visualisieren.\n\n\n\n\nEine gängige Methode, mit Extremwerten umzugehen, ist, \nalle Datenpunkte, die im Boxplot als alleinstehende Punkte gezeigt werden, durch den Median zu ersetzen.\nAchtung: Diese Methode ist nicht perfekt! \nEs gibt viel sophistiziertere Methoden.\n\n\nWir ersetzen dabei alle Werte von ` distance`, für die gilt, dass sie größer sind als Q3 + 1.5*IQR.\n\nQ3:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights_train5 |> \n  summarise(distance_q3 = quantile(distance, prob = .75))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 1\n  distance_q3\n        <dbl>\n1        1183\n```\n\n\n:::\n:::\n\n\n\n\nIQR:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights_train5 |> \n  summarise(distance_iqr = IQR(distance))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 1\n  distance_iqr\n         <dbl>\n1          704\n```\n\n\n:::\n:::\n\n\nDer Grenzwert ist also:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(# Q3\n  flights_train5 |> \n  summarise(distance_iqr = quantile(distance, prob = .75)) \n  ) +\n  1.5 * \n (# IQR\n  flights_train5 |> \n  summarise(distance_iqr = IQR(distance)) \n )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  distance_iqr\n1         2239\n```\n\n\n:::\n:::\n\n\n\nDer Median von `distance` beträgt übrigens:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n flights_train5 |> \n  summarise(distance_md = median(distance)) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 1\n  distance_md\n        <dbl>\n1         762\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nflights_train6 <-\n  flights_train5 |> \n  mutate(distance = \n           case_when(distance > 2239 ~ 762,\n                     TRUE ~ distance))\n```\n:::\n\n\n\nGrob auf Deutsch übersetzt:\n\n>    Wenn ein Flug eine `distance` von mehr als 326 Minuten hat, dann sei die airtime gleich 122, ansonsten immer (\"TRUE\") ist airtime gleich `distance`, bleibt also, wie sie war.\n\n\n\n# lm7: Wie lm5, aber ohne Extremwerte für `distance`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlm7 <-lm(dep_delay ~ ., data = flights_train6)\n\nr2(lm7)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# R2 for Linear Regression\n       R2: 0.018\n  adj. R2: 0.017\n```\n\n\n:::\n:::\n\n\nTja....\n\n# R2 im Testsample \n\n\n\n$R^2$ kann man übrigens auch so berechnen:\n\n\nZuerst fügen wir die Vorhersagen zum Datensatz hinzu:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights_train7_pred <- \n  flights_train6 %>% \n  mutate(lm7_pred = predict(lm7, newdata = flights_train6))  \n```\n:::\n\n\n\nDann berechnen wir das R-Quadrat mit der Funktion `rsq` (wie \"r squared\", R-Quadrat) anhand der beiden relevanten Spalten:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights_train7_pred %>% \n  rsq(truth = dep_delay,\n      estimate = lm7_pred)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 3\n  .metric .estimator .estimate\n  <chr>   <chr>          <dbl>\n1 rsq     standard      0.0176\n```\n\n\n:::\n:::\n\n\n\nDas ist nützlich, wenn man R-Quadrat auf Basis eigener Vorhersagen, im Test-Sample also, berechnen will.\n\nBerechnen wir jetzt die Modellgüte im Testsample.\n\n\nFügen wir die Vorhersagewerte dem Testsample dazu:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights_test4_pred <-\n  flights_test2 %>% \n  mutate(pred_lm7 = predict(lm7, newdata = flights_test2))\n```\n:::\n\n\nCheck:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights_test4_pred %>% \n  select(id, dep_delay, pred_lm7) %>%\n  head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 3\n     id dep_delay pred_lm7\n  <int>     <dbl>    <dbl>\n1    13         3     4.46\n2    15        19    11.6 \n3    28        -8    33.0 \n4    30        -4    16.2 \n5    31       160    20.8 \n6    37        -8     2.79\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nflights_test4_pred |> \n  rsq(truth = dep_delay,\n      estimate = pred_lm7)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 3\n  .metric .estimator .estimate\n  <chr>   <chr>          <dbl>\n1 rsq     standard      0.0184\n```\n\n\n:::\n:::\n\n\nAm schwierigsten ist es, bei den ganzen Nummerierungen nicht durcheinander zu kommen. Hier könnte es sich lohnen, ein übersichtlicheres Verfahren einzuführen (mit den Kosten höherer Komplexität).\n\n\n\n\n# Einreichen\n\n\nDas beste Modell im *Train-Sample* reichen wir ein; in diesem Fall `lm7`.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsubmission_df <- \nflights_test4_pred |> \n  select(id, pred = pred_lm7)  # gleich umbenennen in \"pred\"\n```\n:::\n\n\nCheck:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(submission_df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 2\n     id  pred\n  <int> <dbl>\n1    13  4.46\n2    15 11.6 \n3    28 33.0 \n4    30 16.2 \n5    31 20.8 \n6    37  2.79\n```\n\n\n:::\n:::\n\n\nDas sieht erstmal gut aus.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwrite_csv(submission_df, file = \"Sauer_Sebastian_0123456_Prognose.csv\")\n```\n:::\n\n\n\n\n# Was noch?\n\n\n\nEin nächster Schritt könnte sein, sich folgende Punkte anzuschauen:\n\n\n  - Nominale Variablen berücksichtigen\n  - Variablen mit der höchsten Korrelation berücksichtigen\n  - Interaktionseffekte berücksichtigen\n\nEine Faustregel zu Interaktionen lautet: Wenn zwei Variablen jeweils einen starken Haupteffekt haben, lohnt es sich u.U., den Interaktionseffekt anzuschauen (vgl. Gelman & Hill, 2007, S. 69).\n\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}