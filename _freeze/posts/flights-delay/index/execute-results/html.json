{
  "hash": "65eca4b70d620f568a5dfd684be1f8a8",
  "result": {
    "engine": "knitr",
    "markdown": "---\ndate: 2024-06-22\ndraft: FALSE   # ACHTUNG DRAFT STEHT AUF TRUE!\ntitle: flights-delay\nexecute: \n  eval: true \n  cache: true\n  freeze: true\nhighlight-style: arrow \ncache: true\ntoc: true\nnumber-sections: true\nextype: string\nexsolution: \"\"\nexshuffle: no\ncategories:\n- lm  # ENTER CATEGORIES HERE\n- regression\n- interaction\n- yacsda\n---\n\n\n\n\n\n# Hintergrund und Forschungsfrage\n\n\nWir untersuchen die Forschungsfrage *Was sind Prädiktoren von Flugverspätungen*. \nDazu nutzen wir lineare Modelle als Modellierungsmethoden.\n\nDieser Post knüpft an [den Post zur explorativen Datenanalyse der Flugverspätungen](https://data-se.netlify.app/2021/03/08/eda-zu-flugversp%C3%A4tungen/) an (es gibt auch [hier, Teil 1](https://www.youtube.com/watch?v=t8i_qTonuLM) und [hier, Teil 2](https://youtu.be/AeBqwr2U7MA) ein Video zu diesem EDA-Post).\n\n\n# Setup\n\n## Pakete laden\n\nWirklich wichtig sind nur `tidymodels` und `tidyverse`. Die restlichen Pakete werden nur am Rande benötigt. \nMan sollte auch nur die Pakete laden,\ndie man für die Analyse benötigt.\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(\"tidymodels\")  # Train- und Test-Sample aufteilen\nlibrary(\"tidyverse\")  # data wrangling\nlibrary(\"conflicted\")  # Name clashes finden\nlibrary(\"easystats\")  # stats made easy\n```\n:::\n\n\n\n## Daten laden: Flights 2023\n\nAus Gründen der Datenökonomie nutzen wir eine kleinere Version des Datensatz `flights`. \nWir nutzen nicht mehr die Daten aus dem 2013, sondern die neueren Daten aus dem Jahr 2023.\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(nycflights23)\ndata(flights)\n\nset.seed(42)  # Reproduzierbarkeit\nflights <- \n  flights |> \n  sample_n(size = 3e4)\n```\n:::\n\n\nAchtung: `flights` ist recht groß; die Regressionsmodelle können leicht ein paar Hundert Megabyte groß werden. Das bringt u.U. auch einen modernen Computer irgendwann ins Straucheln.\n\n\n\n\n# flights2: Nicht benötigte Variablen entfernen und ID hinzufügen\n\n::: {.cell}\n\n```{.r .cell-code}\nflights2 <-\n  flights %>% \n  select(-c(year, arr_delay)) %>% \n  drop_na(dep_delay) %>% \n  mutate(id = row_number()) %>% \n  select(id, everything())  # id nach vorne ziehen\n```\n:::\n\n\n\n\n\n# Aufteilung in Train- und Testsample\n\n\nDer Hintergrund zur Idee der Aufteilung in Train- und Test-Stichprobe kann z.b. [hier](https://www.tmwr.org/splitting.html) oder [hier](https://www.springer.com/de/book/9783658215866), Kapitel 15, nachgelesen werden.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights_split <- initial_split(flights2, \n                               strata = dep_delay)\n```\n:::\n\n\n\n# flights_train2, flights_test2\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(42)  # Reproduzierbarkeit\nflights_train2 <- training(flights_split)\nflights_test2 <- testing(flights_split)\n```\n:::\n\n\nDie \"wirkliche Welt\" (was immer das ist) besorgt die Aufteilung von Train- und Test-Sampel für Sie automatisch. Sagen wir, Sie arbeiten für die Flughafen-Aufsicht von New York. Dann haben Sie einen Erfahrungsschatz an Flügen aus der Vergangenheit in Ihrer Datenbank (Train-Sample). Einige Tages kommt Ihr Chef zu Ihnen und sagt: \"Rechnen Sie mir mal die zu erwartende Verspätung der Flüge *im nächsten Monat* aus!\". Da *heute* nicht klar ist, wie die Verspätung der Flüge *in der Zukunft* (nächsten Monat) sein wird, stellen die Flüge des nächsten Monats das Test-Sample dar.\n\nÜbrigens: In der Prüfung besorgt das Aufteilen von Train- und Test-Sample netterweise Ihr Dozent...\n\n\n\n\n# lm0: Nullmodell\n\nEigentlich nicht nötig, das Nullmodell, primär aus didaktischen Gründen berechnet, um zu zeigen, dass in diesem Fall $R^2$ wirklich gleich Null ist.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlm0 <- lm(dep_delay ~ 1, data = flights_train2)\nmodel_parameters(lm0)  # model_parameters zeit die (geschätzten) Regressionsgewichte (Betas)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nParameter   | Coefficient |   SE |         95% CI | t(21918) |      p\n---------------------------------------------------------------------\n(Intercept) |       13.89 | 0.37 | [13.16, 14.63] |    37.18 | < .001\n```\n\n\n:::\n:::\n\n\nWir könnten anstatt `model_parameters` auch `parameters` nutzen; das ist der gleiche Befehl.\n\nAllerdings gibt es den Befehl `parameters` in *zwei* Paketen, es käme also zu einem \"Name Clash\".\nDas umgehen wir, indem wir `model_parameter` nutzen, und nicht `parameters`. \n\n# lm1: origin\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlm1 <- lm(dep_delay ~ origin, data = flights_train2)\nmodel_parameters(lm1)  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nParameter    | Coefficient |   SE |         95% CI | t(21916) |      p\n----------------------------------------------------------------------\n(Intercept)  |       15.11 | 0.66 | [13.82, 16.40] |    22.98 | < .001\norigin [JFK] |        1.37 | 0.94 | [-0.47,  3.21] |     1.46 | 0.145 \norigin [LGA] |       -4.42 | 0.90 | [-6.19, -2.66] |    -4.92 | < .001\n```\n\n\n:::\n:::\n\n\nMan vergleiche:\n\n::: {.cell}\n\n```{.r .cell-code}\nflights_train2 %>% \n  drop_na(dep_delay) %>% \n  group_by(origin) %>% \n  summarise(delay_avg = mean(dep_delay)) %>% \n  mutate(delay_delta = delay_avg - delay_avg[1])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 3\n  origin delay_avg delay_delta\n  <chr>      <dbl>       <dbl>\n1 EWR         15.1        0   \n2 JFK         16.5        1.37\n3 LGA         10.7       -4.42\n```\n\n\n:::\n:::\n\n\nDer Mittelwertsvergleich und das Modell `lm1` sind faktisch informationsgleich.\n\n\n\nAber leider ist es um die Modellgüte nicht so gut bestellt (eigentlich eher \"grottenschlecht\"):\n\n::: {.cell}\n\n```{.r .cell-code}\nr2(lm1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# R2 for Linear Regression\n       R2: 0.002\n  adj. R2: 0.002\n```\n\n\n:::\n:::\n\n\n`lm1` ist so schlecht, wir löschen es gleich wieder...\n::: {.cell}\n\n```{.r .cell-code}\nrm(lm1)\n```\n:::\n\n\n\n# lm2: All in\n\n::: {.cell}\n\n```{.r .cell-code}\n# NICHT AUSFÜHREN\n#lm2_all_in <- lm(dep_delay ~ ., data = flights_train2)\n```\n:::\n\nModell `lm2_all_in` ist hier *keine* gute Idee, da nominale Prädiktoren in Indikatorvariablen umgewandelt werden. Hat ein nominaler Prädiktor sehr viele Stufen (wie hier), so resultieren sehr viele Indikatorvariablen, was dem Regressionsmodell Probleme bereiten kann (bei mir hängt sich R auf). Besser ist es in dem Fall, die Anzahl der Stufen von nominalskalierten Variablen vorab zu begrenzen.\n\nBei kleineren Datensätzen (weniger Variablen, weniger Fälle) lohnt es sich aber oft, das \"All-in-Modell\" auszuprobieren, als Referenzmaßstab für andere Modelle.\n\n\n\n# flights_train3: Textvariablen in Faktorvariablen umwandeln\n\nBegrenzen wir zunächst die Anzahl der Stufen der nominal skalierten Variablen:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights_train3 <- \n  flights_train2 %>% \n  mutate(across(\n    .cols = where(is.character),\n    .fns = as.factor))\n```\n:::\n\nWem das `across` zu kompliziert ist, der kann auch alternativ (synonym) jede Variable einzeln in einen Faktor umwandeln und zwar so:\n\n::: {.cell}\n\n```{.r .cell-code}\nflights_train3a <- \n  flights_train2 %>% \n  mutate(tailnum = as.factor(tailnum),\n         origin = as.factor(origin),\n         dest = as.factor(dest),\n         carrier = as.factor(carrier)\n      )\n```\n:::\n\n\nDas ist einfacher als mit `across`, aber dafür mehr Tipperei.\n\n\nWir müssen die Transformationen, die wir auf das Train-Sample anwenden, auch auf das Test-Sample anwenden:\n\n\n# flights_test3\n\n::: {.cell}\n\n```{.r .cell-code}\nflights_test3 <- \n  flights_test2 %>% \n  mutate(across(\n    .cols = where(is.character),\n    .fns = as.factor))\n```\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights_train3 %>% \n  select(where(is.factor)) %>% \n  names()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"carrier\" \"tailnum\" \"origin\"  \"dest\"   \n```\n\n\n:::\n:::\n\n\n\nZ.B. `dest` hat viele Stufen:\n\n::: {.cell}\n\n```{.r .cell-code}\nflights_train3 %>% \n  count(dest, sort = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 116 × 2\n   dest      n\n   <fct> <int>\n 1 ORD     941\n 2 BOS     933\n 3 ATL     890\n 4 MCO     860\n 5 LAX     816\n 6 MIA     806\n 7 FLL     707\n 8 CLT     673\n 9 SFO     588\n10 DFW     581\n# ℹ 106 more rows\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nflights_train3 %>%\n  count(dest) %>%\n  ggplot() +\n  aes(y = fct_reorder(dest, n), x = n) +\n  geom_col()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n# flights_train4: Faktorstufen zusammenfassen\n\n::: {.cell}\n\n```{.r .cell-code}\nflights_train4 <-\n  flights_train3 %>% \n  mutate(across(\n    .cols = where(is.factor),\n    .fns = fct_lump_prop, prop = .025\n  ))\n```\n:::\n\n\n# Variante mit `fact_lump_n` \n\nSinngemäß bedeutet das:\n\n\"Fasse die Faktorstufen von `dest` zu 8 Gruppen plus einer '*Lump*ensammler-Kategorie' zusammen.\"\n\n::: {.cell}\n\n```{.r .cell-code}\nflights_train3 %>% \n  mutate(dest_lump9 = fct_lump_n(dest, n = 8)\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 21,919 × 19\n      id month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n 1    11     2    22      622            630        -8     1034           1020\n 2    26     9    27     1137           1147       -10     1255           1317\n 3    28    10     8     1751           1759        -8     2106           2110\n 4    37     3    30      807            815        -8      917            930\n 5    39     6    14     1019           1025        -6     1127           1151\n 6    47     9    26     1045           1051        -6     1345           1357\n 7    52     5     9      749            759       -10     1009           1014\n 8    55     2    10      914            920        -6     1044           1115\n 9    59    12    30     1402           1411        -9     1715           1724\n10    61    11    10     1434           1440        -6     1623           1641\n# ℹ 21,909 more rows\n# ℹ 11 more variables: carrier <fct>, flight <int>, tailnum <fct>,\n#   origin <fct>, dest <fct>, air_time <dbl>, distance <dbl>, hour <dbl>,\n#   minute <dbl>, time_hour <dttm>, dest_lump9 <fct>\n```\n\n\n:::\n:::\n\n\nHier sind die Faktorstufen von `dest`:\n\n::: {.cell}\n\n```{.r .cell-code}\nflights_train4$dest |> levels()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"ATL\"   \"BOS\"   \"CLT\"   \"DFW\"   \"FLL\"   \"LAX\"   \"MCO\"   \"MIA\"   \"ORD\"  \n[10] \"RDU\"   \"SFO\"   \"Other\"\n```\n\n\n:::\n:::\n\n\nVisusalsieren wir die Häufigkeit der Faktorstufen:\n\n::: {.cell}\n\n```{.r .cell-code}\nflights_train4 %>%\n  count(dest) %>%\n  ggplot() +\n  aes(y = fct_reorder(dest, n), x = n) +\n  geom_col()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/plot-count-levels-dest-1.png){width=672}\n:::\n:::\n\n\n\n\n\n# flights_test4\n\nVergessen wir nicht, die Transformation auch auf das Test-Sample anzuwenden:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights_test4 <-\n  flights_test3 %>% \n  mutate(across(\n    .cols = where(is.factor),\n    .fns = fct_lump_prop, prop = .025\n  ))\n```\n:::\n\n\n\nWichtig! Im Alle Faktorstufen, die im Test-Set vorkommen, müssen auch im Train-Set vorkommen. Sonst können wir das Regressionsmodell nicht berechnen.\n\n::: {.cell}\n\n```{.r .cell-code}\nlevels(flights_test4$dest) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"ATL\"   \"BOS\"   \"CLT\"   \"DFW\"   \"FLL\"   \"LAX\"   \"MCO\"   \"MIA\"   \"ORD\"  \n[10] \"Other\"\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlevels(flights_train4$dest)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"ATL\"   \"BOS\"   \"CLT\"   \"DFW\"   \"FLL\"   \"LAX\"   \"MCO\"   \"MIA\"   \"ORD\"  \n[10] \"RDU\"   \"SFO\"   \"Other\"\n```\n\n\n:::\n:::\n\nDas sieht gut aus: Alle Faktorstufen im Test-Set sind im Train-Set enthalten.\n\n# lm3: Alle zusammengefassten Faktorvariablen\n\n::: {.cell}\n\n```{.r .cell-code}\nlm3 <- flights_train4 %>% \n  select(dep_delay, where(is.factor), -tailnum, -id) %>% \n  lm(dep_delay ~ ., data = .)\n```\n:::\n\nAchtung! Falls ein Faktor nur über eine einzige Faktorstufe verfügt, wird das Regressionsmodell zusammenbrechen mit einer Fehlermeldung. Adios!\n\n\n\n\nDer Punkt bei `dep_delay ~ .` meint \"nimm alle Variablen im Datensatz (bis auf `dep_delay`)\".\n\nDer Punkt bei `data = .` nimm die Tabelle, wie sie dir im letzten Schritt mundgerecht aufbereitet wurde. Man hätte hier auch `flights_train4` schreiben können, aber dann hätten wir noch `tailnum` etc. entfernen müssen.\n\n\n\n\n\n\nEigentlich brauchen wir nicht so viele Dezimalstellen ...\n\n::: {.cell}\n\n```{.r .cell-code}\noptions(digits = 2)\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel_parameters(lm3)  # Modellkoeffizienten, also die Beta-Gewichte (\"estimate\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nParameter       | Coefficient |   SE |         95% CI | t(21897) |      p\n-------------------------------------------------------------------------\n(Intercept)     |        8.87 | 2.44 | [ 4.09, 13.66] |     3.63 | < .001\ncarrier [AA]    |        4.76 | 1.85 | [ 1.13,  8.38] |     2.57 | 0.010 \ncarrier [B6]    |       15.25 | 1.53 | [12.24, 18.25] |     9.94 | < .001\ncarrier [DL]    |        5.90 | 1.54 | [ 2.88,  8.93] |     3.82 | < .001\ncarrier [NK]    |        5.98 | 2.42 | [ 1.23, 10.73] |     2.47 | 0.014 \ncarrier [UA]    |        8.90 | 1.71 | [ 5.54, 12.25] |     5.20 | < .001\ncarrier [WN]    |        8.89 | 2.52 | [ 3.94, 13.83] |     3.52 | < .001\ncarrier [YX]    |       -4.18 | 1.40 | [-6.93, -1.43] |    -2.98 | 0.003 \ncarrier [Other] |        9.39 | 2.27 | [ 4.93, 13.85] |     4.13 | < .001\norigin [JFK]    |        0.42 | 1.25 | [-2.03,  2.87] |     0.34 | 0.735 \norigin [LGA]    |       -1.96 | 1.15 | [-4.21,  0.28] |    -1.71 | 0.087 \ndest [BOS]      |        0.60 | 2.67 | [-4.62,  5.83] |     0.23 | 0.821 \ndest [CLT]      |        1.41 | 3.00 | [-4.46,  7.29] |     0.47 | 0.637 \ndest [DFW]      |        2.07 | 3.07 | [-3.94,  8.08] |     0.68 | 0.500 \ndest [FLL]      |        2.30 | 2.84 | [-3.26,  7.86] |     0.81 | 0.418 \ndest [LAX]      |       -0.77 | 2.74 | [-6.14,  4.60] |    -0.28 | 0.778 \ndest [MCO]      |        6.49 | 2.68 | [ 1.23, 11.75] |     2.42 | 0.016 \ndest [MIA]      |       -1.99 | 2.83 | [-7.53,  3.55] |    -0.70 | 0.482 \ndest [ORD]      |        0.89 | 2.67 | [-4.35,  6.13] |     0.33 | 0.738 \ndest [RDU]      |        2.16 | 3.05 | [-3.82,  8.15] |     0.71 | 0.479 \ndest [SFO]      |       -1.05 | 3.01 | [-6.95,  4.85] |    -0.35 | 0.728 \ndest [Other]    |       -0.07 | 1.99 | [-3.97,  3.84] |    -0.03 | 0.974 \n```\n\n\n:::\n:::\n\n\nWie man sieht, wird eine nominalskalierte Variable mit vielen Stufen in entsprechend (viele!) binäre Variablen umgewandelt, die jeweils einen Regressionskoeffizienten ergeben.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nr2(lm3)  # R^2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# R2 for Linear Regression\n       R2: 0.016\n  adj. R2: 0.015\n```\n\n\n:::\n:::\n\n\nEin mageres R-Quadrat.\n\n\n# lm4: Alle metrischen Variablen\n\n\nWas sind noch mal unsere metrischen Variablen:\n\n::: {.cell}\n\n```{.r .cell-code}\nflights_train4 %>% \n  select(where(is.numeric)) %>% \n  names()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"id\"             \"month\"          \"day\"            \"dep_time\"      \n [5] \"sched_dep_time\" \"dep_delay\"      \"arr_time\"       \"sched_arr_time\"\n [9] \"flight\"         \"air_time\"       \"distance\"       \"hour\"          \n[13] \"minute\"        \n```\n\n\n:::\n:::\n\n\nOk, jetzt eine Regression mit diesen Variablen (ober ohne die ID-Variable):\n\n::: {.cell}\n\n```{.r .cell-code}\nlm4 <- \n  flights_train4 %>% \n  select(dep_delay, where(is.numeric), -id) %>% \n  lm(dep_delay ~ ., data = .)\n```\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nr2(lm4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# R2 for Linear Regression\n       R2: 0.061\n  adj. R2: 0.061\n```\n\n\n:::\n:::\n\nTja, das $R^2$ hat einen nicht gerade um ...\n\n\n\n# lm5: Alle metrischen und alle (zusammengefassten) nominalen Variablen\n\nWelche Variablen sind jetzt alle an Bord?\n\n::: {.cell}\n\n```{.r .cell-code}\nflights_train4 %>% \n  names()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"id\"             \"month\"          \"day\"            \"dep_time\"      \n [5] \"sched_dep_time\" \"dep_delay\"      \"arr_time\"       \"sched_arr_time\"\n [9] \"carrier\"        \"flight\"         \"tailnum\"        \"origin\"        \n[13] \"dest\"           \"air_time\"       \"distance\"       \"hour\"          \n[17] \"minute\"         \"time_hour\"     \n```\n\n\n:::\n:::\n\n`time_hour` nehmen wir noch einmal raus, da es zum einen redundant ist zu `hour` etc. und zum anderen noch zusätzlicher Aufbereitung bedarf.\n\n::: {.cell}\n\n```{.r .cell-code}\nflights_train4 %>% \n  select(minute) %>% \n  describe_distribution()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nVariable |  Mean |    SD | IQR |         Range | Skewness | Kurtosis |     n | n_Missing\n----------------------------------------------------------------------------------------\nminute   | 28.58 | 19.62 |  35 | [0.00, 59.00] |     0.02 |    -1.19 | 21919 |         0\n```\n\n\n:::\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights_train4 <- \n  flights_train4 %>% \n  select(-time_hour, -tailnum, -id, -minute)    # \"minute\" machte Probleme, besser rausnehmen\n  \nlm5 <-lm(dep_delay ~ ., data = flights_train4)\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nr2(lm5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# R2 for Linear Regression\n       R2: 0.068\n  adj. R2: 0.067\n```\n\n\n:::\n:::\n\nDer Vorhersage-Gott ist nicht mit uns. Vielleicht sollten wir zu einem ehrlichen Metier als Schuhverkäufer umsatteln ...\n\n\n# flights_train5: Fehlenden Werte ersetzen\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights_train4 |> \n  describe_distribution() |> \n  select(Variable, n_Missing)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nVariable       | n_Missing\n--------------------------\nmonth          |         0\nday            |         0\ndep_time       |         0\nsched_dep_time |         0\ndep_delay      |         0\narr_time       |        40\nsched_arr_time |         0\nflight         |         0\nair_time       |        98\ndistance       |         0\nhour           |         0\n```\n\n\n:::\n:::\n\nGlücklicherweise haben wir nicht zu viele fehlende Werte.\nBei der Größe der Stichprobe fällt die Anzahl wenig ins Gewicht.\nAber zu Übungszwecken ersetzen wir mal die fehlenden Werte.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights_train5 <-\n  flights_train4 |> \n  mutate(air_time = replace_na(air_time, mean(air_time, na.rm = TRUE)))\n```\n:::\n\n\n\n# lm6: Wie lm5, aber ohne fehlende Werte\n\n::: {.cell}\n\n```{.r .cell-code}\nlm6 <-lm(dep_delay ~ ., data = flights_train5)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nr2(lm6)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# R2 for Linear Regression\n       R2: 0.068\n  adj. R2: 0.067\n```\n\n\n:::\n:::\n\n\n# flights_train6: Extremwerte entfernen\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(DataExplorer)\n\nflights_train5 |> \n  select(where(is.numeric)) |> \n  plot_density()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/plot-densities-1.png){width=672}\n:::\n:::\n\nEs sieht so aus, als wäre `air_time` deutlich rechtsschief mit einigen Ausreißern.\n\nBetrachten wir noch Boxplots, die auch gut Extermwerte visualisieren.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights_train5 |> \n  select(where(is.numeric), \"origin\") |> \n  plot_boxplot(by = \"origin\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/plot-boxplots-1.png){width=672}\n:::\n:::\n\n\nEine gängige Methode, mit Extermwerten umzugehen, ist, alle Datenpunkte, die im Boxplot als alleinstehende Punkte gezeigt werden, durch den Median zu ersetzen.\nAchtung: Diese Methode ist nicht perfekt! Es gibt viel sophistiziertere Methoden.\n\n\nWir ersetzen dabei alle Werte von ` air_time`, für die gilt, dass sie größer sind als Q3 + 1.5*IQR.\n\nQ3:\n\n::: {.cell}\n\n```{.r .cell-code}\nflights_train5 |> \n  summarise(iqr_airtime = quantile(air_time, prob = .75))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 1\n  iqr_airtime\n        <dbl>\n1         177\n```\n\n\n:::\n:::\n\n\n\nIQR:\n\n::: {.cell}\n\n```{.r .cell-code}\nflights_train5 |> \n  summarise(iqr_airtime = IQR(air_time))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 1\n  iqr_airtime\n        <dbl>\n1          99\n```\n\n\n:::\n:::\n\nDer Grenzwert ist also:\n\n::: {.cell}\n\n```{.r .cell-code}\n(# Q3\n  flights_train5 |> \n  summarise(iqr_airtime = quantile(air_time, prob = .75)) \n  ) +\n  1.5 * \n (# IQR\n  flights_train5 |> \n  summarise(iqr_airtime = IQR(air_time)) \n )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  iqr_airtime\n1         326\n```\n\n\n:::\n:::\n\n\nDer Median von `air_time` beträgt übrigens:\n\n::: {.cell}\n\n```{.r .cell-code}\n flights_train5 |> \n  summarise(iqr_airtime = median(air_time)) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 1\n  iqr_airtime\n        <dbl>\n1         122\n```\n\n\n:::\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights_train6 <-\n  flights_train5 |> \n  mutate(air_time = \n           case_when(air_time > 326 ~ 122,\n                     TRUE ~ air_time))\n```\n:::\n\n\nGrob auf Deutsch übersetzt:\n\n>    Wenn ein Flug eine `air_time` von mehr als 326 Minuten hat, dann sei die airtime gleich 122, ansonsten immer (\"TRUE\") ist airtime gleich `air_time`, bleibt also, wie sie war.\n\n\n\n# lm7: Wie lm5, aber ohne Extremwerte für `air_time`\n\n::: {.cell}\n\n```{.r .cell-code}\nlm7 <-lm(dep_delay ~ ., data = flights_train6)\n\nr2(lm7)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# R2 for Linear Regression\n       R2: 0.069\n  adj. R2: 0.067\n```\n\n\n:::\n:::\n\nTja....\n\n# R2 im Testsample \n\n\n\n$R^2$ kann man übrigens auch so berechnen:\n\n\nZuerst fügen wir die Vorhersagen zum Datensatz hinzu:\n\n::: {.cell}\n\n```{.r .cell-code}\nflights_train7_pred <- \n  flights_train6 %>% \n  mutate(lm7_pred = predict(lm7, newdata = flights_train6))  \n```\n:::\n\n\nDann berechnen wir das R-Quadrat mit der Funktion `rsq` (wie \"r squared\") anhand der beiden relevanten Spalten:\n\n::: {.cell}\n\n```{.r .cell-code}\nflights_train7_pred %>% \n  rsq(truth = dep_delay,\n      estimate = lm7_pred)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 3\n  .metric .estimator .estimate\n  <chr>   <chr>          <dbl>\n1 rsq     standard      0.0686\n```\n\n\n:::\n:::\n\n\n\n\nBerechnen wir jetzt die Modellgüte im Testsample.\n\n\nFügen wir die Vorhersagewerte dem Testsample dazu:\n\n::: {.cell}\n\n```{.r .cell-code}\nflights_test4_pred <-\n  flights_test4 %>% \n  mutate(pred_lm7 = predict(lm7, newdata = flights_test4))\n```\n:::\n\nCheck:\n\n::: {.cell}\n\n```{.r .cell-code}\nflights_test4_pred %>% \n  select(id, dep_delay, pred_lm7) %>%\n  head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 3\n     id dep_delay pred_lm7\n  <int>     <dbl>    <dbl>\n1     1        -5    11.0 \n2     2        48    81.1 \n3     3        -1     4.31\n4     4       -10     6.30\n5     7        -3    18.0 \n6     8         5    27.9 \n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntest_rsq <- \n tibble(model = \"lm7\") %>% \n  mutate(rsq = rsq_vec(truth = flights_test4_pred$dep_delay,\n                       estimate = flights_test4_pred$pred_lm7))\n\ntest_rsq\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 2\n  model    rsq\n  <chr>  <dbl>\n1 lm7   0.0824\n```\n\n\n:::\n:::\n\nAm schwierigsten ist es, bei den ganzen Nummerierungen nicht durcheinander zu kommen. Hier könnte es sich lohnen, ein übersichtlicheres Verfahren einzuführen (mit den Kosten höherer Komplexität).\n\n\nPrüfen wir noch, wie viele fehlende Werte es bei den vorhergesagten Werten gibt:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights_test4_pred %>% \n  summarise(pred_isna = sum(is.na(pred_lm7)),\n            pred_isna_prop = pred_isna / nrow(flights_test4_pred))  # prop wie \"proportion\" (Anteil)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 2\n  pred_isna pred_isna_prop\n      <int>          <dbl>\n1        29        0.00397\n```\n\n\n:::\n:::\n\nDa fehlende Werte u.U. mit dem Mittelwert (der übrigen prognostizierten Werte) aufgefüllt werden, erledigen wir das gleich, um den Effekt auf $R^2$ abzuschätzen:\n\n::: {.cell}\n\n```{.r .cell-code}\nflights_test4_pred2 <- \nflights_test4_pred %>% \n  mutate(pred_lm7 = replace_na(pred_lm7, mean(pred_lm7, na.rm = TRUE)))\n```\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights_test4_pred2 %>% \n  summarise(sum(is.na(pred_lm7)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 1\n  `sum(is.na(pred_lm7))`\n                   <int>\n1                      0\n```\n\n\n:::\n:::\n\nKeine fehlenden Werte mehr.\n\n\nWie sieht $R^2$ jetzt aus?\n\n::: {.cell}\n\n```{.r .cell-code}\nflights_test4_pred2 %>% \n  rsq(truth = dep_delay, estimate = pred_lm7)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 3\n  .metric .estimator .estimate\n  <chr>   <chr>          <dbl>\n1 rsq     standard      0.0803\n```\n\n\n:::\n:::\n\nKeine (nennenswerte) Veränderung.\n\n\n\n::: {.cell}\n\n:::\n\n\n\n# Einreichen\n\n\nDas beste Modell im *Train-Sample* reichen wir ein; in diesem Fall `lm7`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsubmission_df <- \nflights_test4_pred2 |> \n  select(id, pred = pred_lm7)  # gleich umbenennen in \"pred\"\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwrite_csv(submission_df, file = \"Sauer_Sebastian_0123456_Prognose.csv\")\n```\n:::\n\n\n\n# Was noch?\n\n## Mehr geht immer...\n\nEin nächster Schritt könnte sein, sich folgende Punkte anzuschauen:\n\n  - Interaktionen\n  - Polynome\n  - Voraussetzungen\n\nEine Faustregel zu Interaktionen lautet: Wenn zwei Variablen jeweils einen starken Haupteffekt haben, lohnt es sich u.U., den Interaktionseffekt anzuschauen (vgl. Gelman & Hill, 2007, S. 69).\n\n\n## Tidymodels\n\nDas ständige Updaten des Test-Datensatzes nervt; mit `tidymodels` wird es komfortabler und man hat Zugang zu leistungsfähigeren Prognosemodellen. [Hier](https://www.tmwr.org/) findet sich ein Einstieg und hier eine [Fallstudie mit Tutorial](https://www.tidymodels.org/start/models/).\n\n\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}